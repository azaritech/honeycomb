[
  {
    "__docId__": 1,
    "kind": "external",
    "name": "Infinity",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Infinity",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Infinity",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 2,
    "kind": "external",
    "name": "NaN",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NaN",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~NaN",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 3,
    "kind": "external",
    "name": "undefined",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~undefined",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 4,
    "kind": "external",
    "name": "null",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/null",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~null",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 5,
    "kind": "external",
    "name": "Object",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Object",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 6,
    "kind": "external",
    "name": "object",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~object",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 7,
    "kind": "external",
    "name": "Function",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Function",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 8,
    "kind": "external",
    "name": "function",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~function",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 9,
    "kind": "external",
    "name": "Boolean",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Boolean",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 10,
    "kind": "external",
    "name": "boolean",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~boolean",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 11,
    "kind": "external",
    "name": "Symbol",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Symbol",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 12,
    "kind": "external",
    "name": "Error",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Error",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 13,
    "kind": "external",
    "name": "EvalError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/EvalError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~EvalError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 14,
    "kind": "external",
    "name": "InternalError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/InternalError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~InternalError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 15,
    "kind": "external",
    "name": "RangeError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RangeError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~RangeError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 16,
    "kind": "external",
    "name": "ReferenceError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ReferenceError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~ReferenceError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 17,
    "kind": "external",
    "name": "SyntaxError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SyntaxError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~SyntaxError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 18,
    "kind": "external",
    "name": "TypeError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~TypeError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 19,
    "kind": "external",
    "name": "URIError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/URIError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~URIError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 20,
    "kind": "external",
    "name": "Number",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Number",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 21,
    "kind": "external",
    "name": "number",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~number",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 22,
    "kind": "external",
    "name": "Date",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Date",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 23,
    "kind": "external",
    "name": "String",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~String",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 24,
    "kind": "external",
    "name": "string",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~string",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 25,
    "kind": "external",
    "name": "RegExp",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~RegExp",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 26,
    "kind": "external",
    "name": "Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 27,
    "kind": "external",
    "name": "Int8Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int8Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Int8Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 28,
    "kind": "external",
    "name": "Uint8Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint8Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 29,
    "kind": "external",
    "name": "Uint8ClampedArray",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8ClampedArray",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint8ClampedArray",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 30,
    "kind": "external",
    "name": "Int16Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int16Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Int16Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 31,
    "kind": "external",
    "name": "Uint16Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint16Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint16Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 32,
    "kind": "external",
    "name": "Int32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int32Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Int32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 33,
    "kind": "external",
    "name": "Uint32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint32Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 34,
    "kind": "external",
    "name": "Float32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Float32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 35,
    "kind": "external",
    "name": "Float64Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float64Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Float64Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 36,
    "kind": "external",
    "name": "Map",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Map",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 37,
    "kind": "external",
    "name": "Set",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Set",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 38,
    "kind": "external",
    "name": "WeakMap",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~WeakMap",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 39,
    "kind": "external",
    "name": "WeakSet",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakSet",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~WeakSet",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 40,
    "kind": "external",
    "name": "ArrayBuffer",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~ArrayBuffer",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 41,
    "kind": "external",
    "name": "DataView",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~DataView",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 42,
    "kind": "external",
    "name": "JSON",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~JSON",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 43,
    "kind": "external",
    "name": "Promise",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Promise",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 44,
    "kind": "external",
    "name": "Generator",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Generator",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 45,
    "kind": "external",
    "name": "GeneratorFunction",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/GeneratorFunction",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~GeneratorFunction",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 46,
    "kind": "external",
    "name": "Reflect",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Reflect",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 47,
    "kind": "external",
    "name": "Proxy",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Proxy",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 48,
    "kind": "file",
    "name": "src/grid/class.js",
    "content": "import { ensureXY } from '../utils'\nimport PointFactory from '../point'\n\nconst Point = PointFactory({ ensureXY })\n\n/**\n * @private\n *\n * The only way to prevent setting invalid items in a grid (`grid[0] = 'not a hex'`) is by using proxies.\n * A proxy can have a `set` trap that can prevent the setting of invalid hexes.\n *\n * Some approaches include:\n * 1. Wrapping the grid instance returned from GridFactory in a proxy.\n * 2. Putting a proxy in the prototype chain of Grid (this \"shields\" the Array prototype methods).\n * 3. Using a proxy to forward certain calls to the Array prototype (and not extending Array at all).\n */\n\nexport default class Grid extends Array {\n    /**\n     * @private\n     * @param {*} value     Any value.\n     * @returns {boolean}   Whether the passed value is a valid hex.\n     */\n    static isValidHex(value) {\n        return (value || {}).__isHoneycombHex === true\n    }\n\n    /**\n     * @memberof Grid#\n     * @override\n     * @throws {TypeError}  It makes no sense for a grid to fill it with arbitrary values, because it should only contain valid hexes.\n     *\n     * @returns {TypeError} An error.\n     */\n    fill() {\n        throw new TypeError('Grid.prototype.fill is not implemented')\n    }\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/includes|Array#includes},\n     * but searches the passed hex (which can also be a {@link point}.\n     *\n     * @memberof Grid#\n     * @override\n     *\n     * @param {point} point             The coordinates to search for.\n     * @param {number} [fromIndex=0]    Optional index to start searching.\n     *\n     * @returns {boolean}               Whether the hex is included in the grid.\n     *\n     * @example\n     * const Grid = Honeycomb.defineGrid()\n     * const Hex = Grid.Hex\n     * const grid = Grid(Hex(0))    // [ { x: 0, y: 0 } ]\n     *\n     * grid.includes(Hex(0))        // true\n     * grid.includes([0, 0])        // true\n     * grid.includes(Hex(0), 1)     // false\n     * grid.includes(Hex(5, 7))     // false\n     */\n    includes(point, fromIndex = 0) {\n        return !!(this.indexOf(point, fromIndex) + 1)\n    }\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf|Array#indexOf},\n     * but accepts a {@link point} and internally uses {@link Hex#equals} as a comparator.\n     *\n     * @memberof Grid#\n     * @override\n     *\n     * @param {point} point             The coordinates to search for.\n     * @param {number} [fromIndex=0]    Optional index to start searching.\n     *                                  If negative, it is taken as the offset from the end of the grid.\n     *\n     * @returns {number}                The index of the found hex (first from the left) or -1 if the hex wasn't found.\n     *\n     * @example\n     * const Grid = Honeycomb.defineGrid()\n     * const Hex = Grid.Hex\n     * const grid = Grid(Hex(0), Hex(1), Hex(0))\n     * // [\n     * //    { x: 0, y: 0 },\n     * //    { x: 1, y: 1 },\n     * //    { x: 0, y: 0 }\n     * // ]\n     *\n     * grid.indexOf(Hex(0))     // 0\n     * grid.indexOf([0, 0])     // 0\n     * grid.indexOf(Hex(0), 1)  // 2\n     * grid.indexOf(Hex(5, 7))  // -1\n     */\n    indexOf(point, fromIndex = 0) {\n        const { length } = this\n        let i = Number(fromIndex)\n\n        point = Point(point)\n        i = Math.max(i >= 0 ? i : length + i, 0)\n\n        for (i; i < length; i++) {\n            if (this[i].equals(point)) {\n                return i\n            }\n        }\n\n        return -1\n    }\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/lastIndexOf|Array#lastIndexOf},\n     * but accepts a {@link point} and internally uses {@link Hex#equals} as a comparator.\n     *\n     * Because all hexes will have different coordinates in most grids, this method behaves the same as {@link Grid#indexOf}.\n     * This method might have a slightly better performance if you know the search hex is at the end of the grid.\n     *\n     * @memberof Grid#\n     * @override\n     *\n     * @param {point} point                 The coordinates to search for.\n     * @param {number} [fromIndex=length-1] Optional index to start searching back from.\n     *                                      If negative, it is taken as the offset from the end of the grid.\n     *\n     * @returns {number}                    The last index of the found hex or -1 if the hex wasn't found.\n     *\n     * @example\n     * const Grid = Honeycomb.defineGrid()\n     * const Hex = Grid.Hex\n     * const grid = Grid(Hex(0), Hex(1), Hex(0))\n     * // [\n     * //    { x: 0, y: 0 },\n     * //    { x: 1, y: 1 },\n     * //    { x: 0, y: 0 }\n     * // ]\n     *\n     * grid.lastIndexOf(Hex(0))     // 2\n     * grid.lastIndexOf([0, 0])     // 2\n     * grid.lastIndexOf(Hex(0), 1)  // 0\n     * grid.lastIndexOf(Hex(5, 7))  // -1\n     */\n    lastIndexOf(point, fromIndex = this.length - 1) {\n        const { length } = this\n        let i = Number(fromIndex)\n\n        point = Point(point)\n        i = i >= 0 ? Math.min(i, length - 1) : length + i\n\n        for (i; i >= 0; i--) {\n            if (this[i].equals(point)) {\n                return i\n            }\n        }\n\n        return -1\n    }\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/push|Array#push},\n     * but filters out any passed invalid hexes.\n     *\n     * @memberof Grid#\n     * @override\n     *\n     * @param {...hex} [hexes]  Hexes to add to the end of the grid. Invalid hexes are ignored.\n     *\n     * @returns {number}        The new length of the grid.\n     *\n     * @example\n     * const Grid = Honeycomb.defineGrid()\n     * const Hex = Grid.Hex\n     *\n     * const grid = Grid(Hex(0))    // [{ x: 0, y: 0 }]\n     * grid.push(Hex(1))            // 2\n     * grid                         // [{ x: 0, y: 0 }, { x: 1, y: 1 }]\n     *\n     * grid.push('invalid')         // 2\n     * grid                         // [{ x: 0, y: 0 }, { x: 1, y: 1 }]\n     */\n    push(...hexes) {\n        return super.push(...hexes.filter(Grid.isValidHex))\n    }\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice|Array#splice},\n     * but filters out any passed invalid hexes.\n     *\n     * @memberof Grid#\n     * @override\n     *\n     * @param {number} start                        Index at which to start changing the grid.\n     * @param {number} [deleteCount=length-start]   Amount of hexes to delete.\n     * @param {...hex} [hexes=[]]                   The hexes to add to the grid, beginning at the `start`.\n     *\n     * @returns {hex[]}                             A grid with the deleted hexes (if any).\n     *\n     * @example\n     * const Grid = Honeycomb.defineGrid()\n     * const Hex = Grid.Hex\n     * const grid = Grid.rectangle({ width: 2, height: 1 })\n     * // [\n     * //    { x: 0, y: 0 },\n     * //    { x: 1, y: 0 },\n     * //    { x: 0, y: 1 },\n     * //    { x: 1, y: 1 }\n     * // ]\n     *\n     * grid.splice(2)               // [{ x: 0, y: 1 }, { x: 1, y: 1 }] <- deleted hexes\n     * grid                         // [{ x: 0, y: 0 }, { x: 1, y: 0 }] <- leftover hexes\n     *\n     * grid.splice(2, 1)            // [{ x: 0, y: 1 }]\n     * grid                         // [{ x: 0, y: 0 }, { x: 1, y: 0 }, { x: 1, y: 1 }]\n     *\n     * grid.splice(2, 1, Hex(2))    // [{ x: 0, y: 1 }]\n     * grid\n     * // [\n     * //    { x: 0, y: 0 },\n     * //    { x: 1, y: 0 },\n     * //    { x: 2, y: 2 },\n     * //    { x: 1, y: 1 }\n     * // ]\n     */\n    splice(start, deleteCount, ...hexes) {\n        // when deleteCount is undefined/null, it's casted to 0, deleting 0 hexes\n        // this is not according to spec: it should delete all hexes (starting from `start`)\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice\n        if (deleteCount == null) {\n            return super.splice(start)\n        }\n\n        return super.splice(start, deleteCount, ...hexes.filter(Grid.isValidHex))\n    }\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/unshift|Array#unshift},\n     * but filters out any passed invalid hexes.\n     *\n     * @memberof Grid#\n     * @override\n     *\n     * @param {...hex} [hexes]  Hexes to add to the start of the grid. Invalid hexes are ignored.\n     *\n     * @returns {number}        The new length of the grid.\n     *\n     * @example\n     * const Grid = Honeycomb.defineGrid()\n     * const Hex = Grid.Hex\n     *\n     * const grid = Grid(Hex(0))    // [{ x: 0, y: 0 }]\n     * grid.unshift(Hex(1))         // 2\n     * grid                         // [{ x: 1, y: 1 }, { x: 0, y: 0 }]\n     *\n     * grid.unshift('invalid')      // 2\n     * grid                         // [{ x: 1, y: 1 }, { x: 0, y: 0 }]\n     */\n    unshift(...hexes) {\n        return super.unshift(...hexes.filter(Grid.isValidHex))\n    }\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/concat|Array#concat}.\n     * @memberof Grid#\n     * @method concat\n     * @instance\n     */\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin|Array#copyWithin}.\n     * @memberof Grid#\n     * @method copyWithin\n     * @instance\n     */\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/entries|Array#entries}.\n     * @memberof Grid#\n     * @method entries\n     * @instance\n     */\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every|Array#every}.\n     * @memberof Grid#\n     * @method every\n     * @instance\n     */\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter|Array#filter}.\n     * @memberof Grid#\n     * @method filter\n     * @instance\n     */\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find|Array#find}.\n     * @memberof Grid#\n     * @method find\n     * @instance\n     */\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex|Array#findIndex}.\n     * @memberof Grid#\n     * @method findIndex\n     * @instance\n     */\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach|Array#forEach}.\n     * @memberof Grid#\n     * @method forEach\n     * @instance\n     */\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/join|Array#join}.\n     * @memberof Grid#\n     * @method join\n     * @instance\n     */\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/keys|Array#keys}.\n     * @memberof Grid#\n     * @method keys\n     * @instance\n     */\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map|Array#map}.\n     * @memberof Grid#\n     * @method map\n     * @instance\n     */\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/pop|Array#pop}.\n     * @memberof Grid#\n     * @method pop\n     * @instance\n     */\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce|Array#reduce}.\n     * @memberof Grid#\n     * @method reduce\n     * @instance\n     */\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight|Array#reduceRight}.\n     * @memberof Grid#\n     * @method reduceRight\n     * @instance\n     */\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse|Array#reverse}.\n     * @memberof Grid#\n     * @method reverse\n     * @instance\n     */\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/shift|Array#shift}.\n     * @memberof Grid#\n     * @method shift\n     * @instance\n     */\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some|Array#some}.\n     * @memberof Grid#\n     * @method some\n     * @instance\n     */\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort|Array#sort}.\n     * @memberof Grid#\n     * @method sort\n     * @instance\n     */\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/toLocaleString|Array#toLocaleString}.\n     * @memberof Grid#\n     * @method toLocaleString\n     * @instance\n     */\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/toString|Array#toString}.\n     * @memberof Grid#\n     * @method toString\n     * @instance\n     */\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/values|Array#values}.\n     * @memberof Grid#\n     * @method values\n     * @instance\n     */\n}\n",
    "static": true,
    "longname": "/Users/abbe/Projects/honeycomb/src/grid/class.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 49,
    "kind": "variable",
    "name": "Point",
    "memberof": "src/grid/class.js",
    "static": true,
    "longname": "src/grid/class.js~Point",
    "access": "public",
    "export": false,
    "importPath": "honeycomb-grid/src/grid/class.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 50,
    "kind": "class",
    "name": "Grid",
    "memberof": "src/grid/class.js",
    "static": true,
    "longname": "src/grid/class.js~Grid",
    "access": "private",
    "export": true,
    "importPath": "honeycomb-grid/src/grid/class.js",
    "importStyle": "Grid",
    "description": "",
    "lineNumber": 18,
    "interface": false,
    "extends": [
      "Array"
    ],
    "ignore": true
  },
  {
    "__docId__": 51,
    "kind": "method",
    "name": "isValidHex",
    "memberof": "src/grid/class.js~Grid",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/grid/class.js~Grid.isValidHex",
    "access": "private",
    "description": "",
    "lineNumber": 24,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{boolean}   Whether the passed value is a valid hex."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "Any value."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "Whether the passed value is a valid hex."
    },
    "ignore": true
  },
  {
    "__docId__": 52,
    "kind": "method",
    "name": "fill",
    "memberof": "src/grid/class.js~Grid",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/grid/class.js~Grid#fill",
    "access": "public",
    "description": "",
    "lineNumber": 35,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{TypeError} An error."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "TypeError"
      ],
      "spread": false,
      "description": "An error."
    },
    "override": true,
    "throws": [
      {
        "types": [
          "TypeError"
        ],
        "description": "It makes no sense for a grid to fill it with arbitrary values, because it should only contain valid hexes."
      }
    ],
    "params": []
  },
  {
    "__docId__": 53,
    "kind": "method",
    "name": "includes",
    "memberof": "src/grid/class.js~Grid",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/grid/class.js~Grid#includes",
    "access": "public",
    "description": "Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/includes|Array#includes},\nbut searches the passed hex (which can also be a {@link point}.",
    "examples": [
      "const Grid = Honeycomb.defineGrid()\nconst Hex = Grid.Hex\nconst grid = Grid(Hex(0))    // [ { x: 0, y: 0 } ]\n\ngrid.includes(Hex(0))        // true\ngrid.includes([0, 0])        // true\ngrid.includes(Hex(0), 1)     // false\ngrid.includes(Hex(5, 7))     // false"
    ],
    "lineNumber": 61,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{boolean}               Whether the hex is included in the grid."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "point"
        ],
        "spread": false,
        "optional": false,
        "name": "point",
        "description": "The coordinates to search for."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "0",
        "defaultRaw": 0,
        "name": "fromIndex",
        "description": "Optional index to start searching."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "Whether the hex is included in the grid."
    },
    "override": true
  },
  {
    "__docId__": 54,
    "kind": "method",
    "name": "indexOf",
    "memberof": "src/grid/class.js~Grid",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/grid/class.js~Grid#indexOf",
    "access": "public",
    "description": "Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf|Array#indexOf},\nbut accepts a {@link point} and internally uses {@link Hex#equals} as a comparator.",
    "examples": [
      "const Grid = Honeycomb.defineGrid()\nconst Hex = Grid.Hex\nconst grid = Grid(Hex(0), Hex(1), Hex(0))\n// [\n//    { x: 0, y: 0 },\n//    { x: 1, y: 1 },\n//    { x: 0, y: 0 }\n// ]\n\ngrid.indexOf(Hex(0))     // 0\ngrid.indexOf([0, 0])     // 0\ngrid.indexOf(Hex(0), 1)  // 2\ngrid.indexOf(Hex(5, 7))  // -1"
    ],
    "lineNumber": 93,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number}                The index of the found hex (first from the left) or -1 if the hex wasn't found."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "point"
        ],
        "spread": false,
        "optional": false,
        "name": "point",
        "description": "The coordinates to search for."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "0",
        "defaultRaw": 0,
        "name": "fromIndex",
        "description": "Optional index to start searching.\n                                 If negative, it is taken as the offset from the end of the grid."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "The index of the found hex (first from the left) or -1 if the hex wasn't found."
    },
    "override": true
  },
  {
    "__docId__": 55,
    "kind": "method",
    "name": "lastIndexOf",
    "memberof": "src/grid/class.js~Grid",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/grid/class.js~Grid#lastIndexOf",
    "access": "public",
    "description": "Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/lastIndexOf|Array#lastIndexOf},\nbut accepts a {@link point} and internally uses {@link Hex#equals} as a comparator.\n\nBecause all hexes will have different coordinates in most grids, this method behaves the same as {@link Grid#indexOf}.\nThis method might have a slightly better performance if you know the search hex is at the end of the grid.",
    "examples": [
      "const Grid = Honeycomb.defineGrid()\nconst Hex = Grid.Hex\nconst grid = Grid(Hex(0), Hex(1), Hex(0))\n// [\n//    { x: 0, y: 0 },\n//    { x: 1, y: 1 },\n//    { x: 0, y: 0 }\n// ]\n\ngrid.lastIndexOf(Hex(0))     // 2\ngrid.lastIndexOf([0, 0])     // 2\ngrid.lastIndexOf(Hex(0), 1)  // 0\ngrid.lastIndexOf(Hex(5, 7))  // -1"
    ],
    "lineNumber": 140,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number}                    The last index of the found hex or -1 if the hex wasn't found."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "point"
        ],
        "spread": false,
        "optional": false,
        "name": "point",
        "description": "The coordinates to search for."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "length-1",
        "defaultRaw": "length-1",
        "name": "fromIndex",
        "description": "Optional index to start searching back from.\n                                     If negative, it is taken as the offset from the end of the grid."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "The last index of the found hex or -1 if the hex wasn't found."
    },
    "override": true
  },
  {
    "__docId__": 56,
    "kind": "method",
    "name": "push",
    "memberof": "src/grid/class.js~Grid",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/grid/class.js~Grid#push",
    "access": "public",
    "description": "Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/push|Array#push},\nbut filters out any passed invalid hexes.",
    "examples": [
      "const Grid = Honeycomb.defineGrid()\nconst Hex = Grid.Hex\n\nconst grid = Grid(Hex(0))    // [{ x: 0, y: 0 }]\ngrid.push(Hex(1))            // 2\ngrid                         // [{ x: 0, y: 0 }, { x: 1, y: 1 }]\n\ngrid.push('invalid')         // 2\ngrid                         // [{ x: 0, y: 0 }, { x: 1, y: 1 }]"
    ],
    "lineNumber": 178,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number}        The new length of the grid."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "...hex"
        ],
        "spread": true,
        "optional": true,
        "name": "hexes",
        "description": "Hexes to add to the end of the grid. Invalid hexes are ignored."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "The new length of the grid."
    },
    "override": true
  },
  {
    "__docId__": 57,
    "kind": "method",
    "name": "splice",
    "memberof": "src/grid/class.js~Grid",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/grid/class.js~Grid#splice",
    "access": "public",
    "description": "Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice|Array#splice},\nbut filters out any passed invalid hexes.",
    "examples": [
      "const Grid = Honeycomb.defineGrid()\nconst Hex = Grid.Hex\nconst grid = Grid.rectangle({ width: 2, height: 1 })\n// [\n//    { x: 0, y: 0 },\n//    { x: 1, y: 0 },\n//    { x: 0, y: 1 },\n//    { x: 1, y: 1 }\n// ]\n\ngrid.splice(2)               // [{ x: 0, y: 1 }, { x: 1, y: 1 }] <- deleted hexes\ngrid                         // [{ x: 0, y: 0 }, { x: 1, y: 0 }] <- leftover hexes\n\ngrid.splice(2, 1)            // [{ x: 0, y: 1 }]\ngrid                         // [{ x: 0, y: 0 }, { x: 1, y: 0 }, { x: 1, y: 1 }]\n\ngrid.splice(2, 1, Hex(2))    // [{ x: 0, y: 1 }]\ngrid\n// [\n//    { x: 0, y: 0 },\n//    { x: 1, y: 0 },\n//    { x: 2, y: 2 },\n//    { x: 1, y: 1 }\n// ]"
    ],
    "lineNumber": 221,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{hex[]}                             A grid with the deleted hexes (if any)."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "start",
        "description": "Index at which to start changing the grid."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "length-start",
        "defaultRaw": "length-start",
        "name": "deleteCount",
        "description": "Amount of hexes to delete."
      },
      {
        "nullable": null,
        "types": [
          "...hex"
        ],
        "spread": true,
        "optional": true,
        "defaultValue": "[]",
        "defaultRaw": [],
        "name": "hexes",
        "description": "The hexes to add to the grid, beginning at the `start`."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "hex[]"
      ],
      "spread": false,
      "description": "A grid with the deleted hexes (if any)."
    },
    "override": true
  },
  {
    "__docId__": 58,
    "kind": "method",
    "name": "unshift",
    "memberof": "src/grid/class.js~Grid",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/grid/class.js~Grid#unshift",
    "access": "public",
    "description": "Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/unshift|Array#unshift},\nbut filters out any passed invalid hexes.",
    "examples": [
      "const Grid = Honeycomb.defineGrid()\nconst Hex = Grid.Hex\n\nconst grid = Grid(Hex(0))    // [{ x: 0, y: 0 }]\ngrid.unshift(Hex(1))         // 2\ngrid                         // [{ x: 1, y: 1 }, { x: 0, y: 0 }]\n\ngrid.unshift('invalid')      // 2\ngrid                         // [{ x: 1, y: 1 }, { x: 0, y: 0 }]"
    ],
    "lineNumber": 254,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number}        The new length of the grid."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "...hex"
        ],
        "spread": true,
        "optional": true,
        "name": "hexes",
        "description": "Hexes to add to the start of the grid. Invalid hexes are ignored."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "The new length of the grid."
    },
    "override": true
  },
  {
    "__docId__": 59,
    "kind": "file",
    "name": "src/grid/class.spec.js",
    "content": "/* eslint-env mocha */\n\nimport { expect } from 'chai'\nimport sinon from 'sinon'\n\nimport { ensureXY } from '../utils'\nimport Grid from './class'\nimport extendHexFactory from '../hex'\n\nconst Hex = extendHexFactory({ ensureXY })()\n\ndescribe('Grid class', () => {\n    let instance\n\n    beforeEach(() => {\n        instance = new Grid(Hex(0))\n    })\n\n    it('extends Array', () => {\n        expect(new Grid()).to.be.an.instanceOf(Array)\n    })\n\n    describe('Grid.isValidHex', () => {\n        it('returns whether the passed value has the __isHoneycombHex property', () => {\n            expect(Grid.isValidHex(Hex())).to.be.true\n\n            expect(Grid.isValidHex()).to.be.false\n            expect(Grid.isValidHex(undefined)).to.be.false\n            expect(Grid.isValidHex(null)).to.be.false\n            expect(Grid.isValidHex(42)).to.be.false\n            expect(Grid.isValidHex('string')).to.be.false\n            expect(Grid.isValidHex([])).to.be.false\n            expect(Grid.isValidHex({})).to.be.false\n            expect(Grid.isValidHex(true)).to.be.false\n        })\n    })\n\n    describe('Grid#fill', () => {\n        it('throws an error', () => {\n            expect(() => instance.fill()).to.throw(TypeError, 'Grid.prototype.fill is not implemented')\n        })\n    })\n\n    describe('Grid#includes', () => {\n        it('accepts a point', () => {\n            expect(instance.includes([0, 0])).to.be.true\n            expect(instance.includes({ x: 0, y: 0 })).to.be.true\n        })\n\n        describe(`when called with a point that's present in the grid`, () => {\n            it('returns true', () => {\n                expect(instance.includes(Hex(0))).to.be.true\n            })\n        })\n\n        describe(`when called with a point that's not present in the grid`, () => {\n            it('returns false', () => {\n                expect(instance.includes(Hex(1))).to.be.false\n            })\n        })\n\n        describe('when called with start index', () => {\n            it('starts searching from that index', () => {\n                instance = new Grid(Hex(0), Hex(1))\n                expect(instance.includes(Hex(0), 1)).to.be.false\n                expect(instance.includes(Hex(1), 1)).to.be.true\n            })\n        })\n    })\n\n    describe('Grid#indexOf', () => {\n        it('accepts a point', () => {\n            expect(instance.indexOf([0, 0])).to.equal(0)\n            expect(instance.indexOf({ x: 0, y: 0 })).to.equal(0)\n        })\n\n        describe(`when called with a hex-like that's present in the grid`, () => {\n            it('returns its index (from the left)', () => {\n                instance = new Grid(Hex(0), Hex(1), Hex(0))\n                expect(instance.indexOf({ x: 0, y: 0 })).to.equal(0)\n                expect(instance.indexOf({ x: 1, y: 1 })).to.equal(1)\n            })\n        })\n\n        describe(`when called with a hex-like that's not present in the grid`, () => {\n            it('returns -1', () => {\n                expect(instance.indexOf({ x: 1, y: 1 })).to.equal(-1)\n            })\n        })\n\n        describe('when called with start index', () => {\n            it('starts searching from that index', () => {\n                instance = new Grid(Hex(0), Hex(1), Hex(0))\n                expect(instance.indexOf(Hex(0), 1)).to.equal(2)\n                expect(instance.indexOf(Hex(0), 2)).to.equal(2)\n                expect(instance.indexOf(Hex(0), -1)).to.equal(2)\n                expect(instance.indexOf(Hex(0), -2)).to.equal(2)\n                expect(instance.indexOf(Hex(0), -3)).to.equal(0)\n                expect(instance.indexOf(Hex(1), 1)).to.equal(1)\n                expect(instance.indexOf(Hex(1), 2)).to.equal(-1)\n                expect(instance.indexOf(Hex(1), -1)).to.equal(-1)\n                expect(instance.indexOf(Hex(1), -2)).to.equal(1)\n                expect(instance.indexOf(Hex(1), -3)).to.equal(1)\n            })\n        })\n    })\n\n    describe('Grid#lastIndexOf', () => {\n        it('accepts a point', () => {\n            expect(instance.lastIndexOf([0, 0])).to.equal(0)\n            expect(instance.lastIndexOf({ x: 0, y: 0 })).to.equal(0)\n        })\n\n        describe(`when called with a hex-like that's present in the grid`, () => {\n            it('returns its index (from the right)', () => {\n                instance = new Grid(Hex(0), Hex(1), Hex(0))\n                expect(instance.lastIndexOf({ x: 0, y: 0 })).to.equal(2)\n                expect(instance.lastIndexOf({ x: 1, y: 1 })).to.equal(1)\n            })\n        })\n\n        describe(`when called with a hex-like that's not present in the grid`, () => {\n            it('returns -1', () => {\n                expect(instance.lastIndexOf(Hex(1))).to.equal(-1)\n            })\n        })\n\n        describe('when called with start index', () => {\n            it('starts searching back from that index', () => {\n                instance = new Grid(Hex(0), Hex(1), Hex(0))\n                expect(instance.lastIndexOf(Hex(0), 1)).to.equal(0)\n                expect(instance.lastIndexOf(Hex(0), 2)).to.equal(2)\n                expect(instance.lastIndexOf(Hex(0), -1)).to.equal(2)\n                expect(instance.lastIndexOf(Hex(0), -2)).to.equal(0)\n                expect(instance.lastIndexOf(Hex(0), -3)).to.equal(0)\n                expect(instance.lastIndexOf(Hex(1), 1)).to.equal(1)\n                expect(instance.lastIndexOf(Hex(1), 2)).to.equal(1)\n                expect(instance.lastIndexOf(Hex(1), -1)).to.equal(1)\n                expect(instance.lastIndexOf(Hex(1), -2)).to.equal(1)\n                expect(instance.lastIndexOf(Hex(1), -3)).to.equal(-1)\n            })\n        })\n    })\n\n    describe('Grid#push', () => {\n        afterEach(() => {\n            Grid.isValidHex.restore()\n        })\n\n        it('calls Grid.isValidHex', () => {\n            sinon.spy(Grid, 'isValidHex')\n            instance.push('value')\n\n            expect(Grid.isValidHex).to.have.been.calledWith('value')\n        })\n\n        it('pushes only elements that are valid hexes', () => {\n            instance = new Grid()\n            const isValidHex = sinon.stub(Grid, 'isValidHex')\n\n            isValidHex.withArgs('valid').returns(true)\n            isValidHex.withArgs('invalid').returns(false)\n            instance.push('valid', 'invalid')\n\n            expect(instance).to.eql(['valid'])\n        })\n    })\n\n    describe('Grid#splice', () => {\n        it('calls Grid.isValidHex', () => {\n            sinon.spy(Grid, 'isValidHex')\n            instance.splice(0, 0, 'value')\n\n            expect(Grid.isValidHex).to.have.been.calledWith('value')\n\n            Grid.isValidHex.restore()\n        })\n\n        describe('when called with only a start', () => {\n            it('deletes hexes beginning at start and returns the deleted hexes', () => {\n                instance = new Grid(Hex(0), Hex(1), Hex(2))\n                const result = instance.splice(1)\n\n                expect(instance).to.eql([Hex(0)])\n                expect(result).to.eql([Hex(1), Hex(2)])\n            })\n        })\n\n        describe('when called with any elements to add', () => {\n            it('only adds those that are valid hexes', () => {\n                instance = new Grid(Hex(0), Hex(1), Hex(2))\n                const isValidHex = sinon.stub(Grid, 'isValidHex')\n\n                isValidHex.withArgs('valid').returns(true)\n                isValidHex.withArgs('invalid').returns(false)\n                const result = instance.splice(1, 2, 'valid', 'invalid')\n\n                expect(instance).to.eql([Hex(0), 'valid'])\n                expect(result[0]).to.eql(Hex(1))\n                expect(result[1]).to.eql(Hex(2))\n\n                Grid.isValidHex.restore()\n            })\n        })\n    })\n\n    describe('Grid#unshift', () => {\n        afterEach(() => {\n            Grid.isValidHex.restore()\n        })\n\n        it('calls Grid.isValidHex', () => {\n            sinon.spy(Grid, 'isValidHex')\n            instance.unshift('value')\n\n            expect(Grid.isValidHex).to.have.been.calledWith('value')\n        })\n\n        it('adds only elements to the end of the grid that are valid hexes', () => {\n            instance = new Grid()\n            const isValidHex = sinon.stub(Grid, 'isValidHex')\n\n            isValidHex.withArgs('valid').returns(true)\n            isValidHex.withArgs('invalid').returns(false)\n            instance.unshift('valid', 'invalid')\n\n            expect(instance).to.eql(['valid'])\n        })\n    })\n})\n",
    "static": true,
    "longname": "/Users/abbe/Projects/honeycomb/src/grid/class.spec.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 60,
    "kind": "variable",
    "name": "Hex",
    "memberof": "src/grid/class.spec.js",
    "static": true,
    "longname": "src/grid/class.spec.js~Hex",
    "access": "public",
    "export": false,
    "importPath": "honeycomb-grid/src/grid/class.spec.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 61,
    "kind": "file",
    "name": "src/grid/index.js",
    "content": "import { isArray } from 'axis.js'\n\nimport { ensureXY, signedModulo, compassToNumberDirection } from '../utils'\nimport PointFactory from '../point'\nimport Grid from './class'\nimport * as statics from './statics'\nimport * as methods from './prototype'\n\nconst Point = PointFactory({ ensureXY })\n\n/**\n * @private\n */\nexport default function defineGridFactory({ extendHex }) {\n    /**\n     * @function defineGrid\n     *\n     * @memberof Honeycomb\n     * @static\n     *\n     * @description\n     * This function can be used to create {@link Grid} factories by passing it a {@link Hex} factory.\n     *\n     * @param {Hex} [Hex=Honeycomb.extendHex()] A {@link Hex} factory.\n     *                                          If nothing is passed, the default Hex factory is used by calling `Honeycomb.extendHex()` internally.\n     *\n     * @returns {Grid}                          A Grid factory.\n     *\n     * @example\n     * // create a Grid factory that uses the default Hex Factory:\n     * const Grid = Honeycomb.defineGrid()\n     * const hex = Grid.Hex()\n     * hex.size     // 1\n     *\n     * // create your own Hex factory\n     * const CustomHex = Honeycomb.extendHex({ size: 10, custom: '🤓' })\n     * // …and pass it to defineGrid() to create a Grid factory that produces your custom hexes\n     * const CustomGrid = Honeycomb.defineGrid(CustomHex)\n     * const customHex = CustomGrid.Hex()\n     * hex.size     // 10\n     * hex.custom   // 🤓\n     */\n    return function defineGrid(Hex = extendHex()) {\n        // static properties\n        Object.assign(GridFactory, {\n            /**\n             * The {@link Hex} factory the Grid factory was created with.\n             * @memberof Grid\n             * @static\n             * @function\n             */\n            // if Hex isn't unbound, it's `this` will reference GridFactory\n            Hex: Hex.bind(),\n\n            // methods\n            isValidHex: statics.isValidHexFactory({ Grid }),\n            pointToHex: statics.pointToHexFactory({ Point, Hex }),\n            parallelogram: statics.parallelogramFactory({ Grid, Hex }),\n            triangle: statics.triangleFactory({ Grid, Hex }),\n            hexagon: statics.hexagonFactory({ Grid, Hex }),\n            rectangle: statics.rectangleFactory({ Grid, Hex, compassToNumberDirection, signedModulo })\n        })\n\n        // prototype properties\n        Object.assign(\n            Grid.prototype,\n            {\n                // methods\n                get: methods.get,\n                hexesBetween: methods.hexesBetween,\n                neighborsOf: methods.neighborsOfFactory({ Grid, signedModulo, compassToNumberDirection }),\n                set: methods.setFactory({ Grid })\n            }\n        )\n\n        /**\n         * @function Grid\n         *\n         * @description\n         * A function to create hex {@link grid}s and perform various operations on them.\n         *\n         * A Grid factory has several static methods that return {@link grid}s of hexes in a certain shape.\n         * It can also be called with 1 or more hexes or an array of hexes to construct/clone a {@link grid} containing those hexes.\n         *\n         * A {@link grid} extends `Array.prototype`, with some methods overwritten and some new methods added.\n         *\n         * @param {(hex[]|hex)} [arrayOrHex]    An array or a hex. Any invalid hexes are filtered out.\n         * @param {...hex} [hexes]              More hexes. Any invalid hexes are filtered out.\n         *\n         * @returns {grid}                      A grid instance containing only valid hexes.\n         *\n         * @example\n         * const Grid = Honeycomb.defineGrid()\n         * // the Hex factory used by the Grid to produce hexes is available as a property\n         * const Hex = Grid.Hex\n         *\n         * Grid(Hex(3, -1), Hex(2, 0))      // [{ x: 3, y: -1 }, { x: 2, y: 0 }]\n         * Grid([Hex(3, -1), Hex(2, 0)])    // [{ x: 3, y: -1 }, { x: 2, y: 0 }]\n         *\n         * // invalid hexes are filtered out:\n         * Grid('no hex', { x: 3, y: -1 })  // []\n         * Grid(['no hex', Hex(1, -1)])     // [{ x: 1, y: -1 }]\n         *\n         * // clone a grid:\n         * const grid = Grid(Hex(), Hex(1), Hex(2))\n         * const clonedGrid = Grid(grid)    // [{ x: 0, y: 0 }, { x: 1, y: 1 }, { x: 2, y: 2 }]\n         * grid === clonedGrid              // false\n         */\n        function GridFactory(arrayOrHex, ...hexes) {\n            if (isArray(arrayOrHex)) {\n                hexes = arrayOrHex\n            } else {\n                hexes.unshift(arrayOrHex)\n            }\n\n            /**\n             * @typedef {Object} grid\n             * @extends Array\n             *\n             * @property {number} length    Amount of hexes in the grid.\n             */\n            return new Grid(...hexes.filter(Grid.isValidHex))\n        }\n\n        return GridFactory\n    }\n}\n",
    "static": true,
    "longname": "/Users/abbe/Projects/honeycomb/src/grid/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 62,
    "kind": "variable",
    "name": "Point",
    "memberof": "src/grid/index.js",
    "static": true,
    "longname": "src/grid/index.js~Point",
    "access": "public",
    "export": false,
    "importPath": "honeycomb-grid/src/grid/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 63,
    "kind": "function",
    "name": "defineGridFactory",
    "memberof": "src/grid/index.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/grid/index.js~defineGridFactory",
    "access": "private",
    "export": true,
    "importPath": "honeycomb-grid/src/grid/index.js",
    "importStyle": "defineGridFactory",
    "description": "",
    "lineNumber": 14,
    "ignore": true,
    "params": [
      {
        "name": "objectPattern",
        "types": [
          "{\"extendHex\": *}"
        ],
        "defaultRaw": {
          "extendHex": null
        },
        "defaultValue": "{\"extendHex\":null}"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 64,
    "kind": "typedef",
    "name": "grid",
    "memberof": "src/grid/index.js",
    "static": true,
    "longname": "src/grid/index.js~grid",
    "access": "public",
    "description": "",
    "lineNumber": 122,
    "unknown": [
      {
        "tagName": "@extends",
        "tagValue": "Array"
      }
    ],
    "properties": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "length",
        "description": "Amount of hexes in the grid."
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "grid"
    }
  },
  {
    "__docId__": 65,
    "kind": "file",
    "name": "src/grid/index.spec.js",
    "content": "/* eslint-env mocha */\n\nimport { expect } from 'chai'\nimport sinon from 'sinon'\n\nimport { ensureXY } from '../utils'\nimport defineGridFactory from './'\nimport Grid from './class'\nimport extendHexFactory from '../hex'\n\nconst extendHex = extendHexFactory({ ensureXY })\nconst defineGrid = defineGridFactory({ extendHex })\nconst Hex = extendHex()\n\ndescribe('defineGrid', function() {\n    describe('when not passed a function', function() {\n        it(`calls Honeycomb.extendHex() to create a default Hex factory`, function() {\n            const extendHexSpy = sinon.spy(extendHex)\n            const defineGrid = defineGridFactory({ extendHex: extendHexSpy })\n            defineGrid()\n            expect(extendHexSpy).to.have.been.called\n        })\n    })\n\n    it('returns a GridFactory with static methods', function() {\n        const GridFactory = defineGrid()\n        expect(GridFactory).to.be.a('function')\n        const staticProps = Object.keys(GridFactory)\n\n        expect(staticProps).to.eql([\n            'Hex',\n            'isValidHex',\n            'pointToHex',\n            'parallelogram',\n            'triangle',\n            'hexagon',\n            'rectangle'\n        ])\n    })\n\n    it('unbinds the Hex property (binds to undefined)', function() {\n        const boundHex = sinon.spy()\n        const bindSpy = sinon.stub().returns(boundHex)\n        const Hex = { bind: bindSpy }\n        const GridFactory = defineGrid(Hex)\n\n        expect(bindSpy).to.have.been.calledWith(/* undefined */) // passing undefined doesn't work...\n        expect(GridFactory.Hex).to.equal(boundHex)\n\n        GridFactory.Hex()\n        expect(boundHex).to.have.been.called\n    })\n})\n\ndescribe('GridFactory', function() {\n    it('returns a function with the Array prototype in its prototype chain', function() {\n        const instance = defineGrid()()\n        expect(Array.prototype.isPrototypeOf(instance)).to.be.true\n        expect(instance).to.have.property('map').that.equals(Array.prototype.map) // ducktype\n    })\n\n    it('returns a function with the Grid prototype', function() {\n        const GridFactory = defineGrid()\n        const prototype = Object.getPrototypeOf(GridFactory())\n        const prototypeProps = Object.keys(prototype)\n\n        expect(prototypeProps).to.eql([\n            'get',\n            'hexesBetween',\n            'neighborsOf',\n            'set'\n        ])\n    })\n})\n\ndescribe('Grid creation', function() {\n    let GridFactory\n\n    beforeEach(function() {\n        GridFactory = defineGrid(Hex)\n        sinon.spy(Grid, 'isValidHex')\n    })\n\n    afterEach(() => {\n        Grid.isValidHex.restore()\n    })\n\n    describe(`when called with one or more arguments that aren't arrays`, () => {\n        it('calls Grid.isValidHex for each argument', () => {\n            const hex1 = Hex()\n            const hex2 = Hex(2, -4)\n            GridFactory(hex1, hex2)\n\n            expect(Grid.isValidHex).to.have.been.calledWith(hex1)\n            expect(Grid.isValidHex).to.have.been.calledWith(hex2)\n        })\n\n        describe(`when they're valid hexes`, function() {\n            it('returns a grid instance containing those hexes', function() {\n                const hex1 = Hex()\n                const hex2 = Hex(2, -4)\n                const result = GridFactory(hex1, hex2)\n\n                expect(result).to.have.lengthOf(2)\n                expect(result[0]).to.equal(hex1)\n                expect(result[1]).to.equal(hex2)\n            })\n        })\n\n        describe(`when they're valid hexes and other types`, function() {\n            it('returns a grid instance with only the valid hexes', function() {\n                const hex1 = Hex()\n                const hex2 = Hex(2, -4)\n                const result = GridFactory(null, 'string', hex1, {}, hex2, 1)\n\n                expect(result).to.have.lengthOf(2)\n                expect(result[0]).to.equal(hex1)\n                expect(result[1]).to.equal(hex2)\n            })\n        })\n    })\n\n    describe(`when called with an array`, () => {\n        it('calls Grid.isValidHex for each element in the array', () => {\n            const hex1 = Hex()\n            const hex2 = Hex(2, -4)\n            GridFactory([hex1, hex2])\n\n            expect(Grid.isValidHex).to.have.been.calledWith(hex1)\n            expect(Grid.isValidHex).to.have.been.calledWith(hex2)\n        })\n\n        describe('that is a valid grid', function() {\n            it('returns a copy of the grid', function() {\n                const grid = GridFactory(Hex(), Hex())\n                const result = GridFactory(grid)\n\n                expect(result).to.eql(grid)\n                expect(result).to.not.equal(grid)\n            })\n        })\n\n        describe('containing valid hexes', function() {\n            it('returns a grid instance containing those hexes', function() {\n                const hex1 = Hex()\n                const hex2 = Hex(2, -4)\n                const result = GridFactory([hex1, hex2])\n\n                expect(result).to.have.lengthOf(2)\n                expect(result[0]).to.equal(hex1)\n                expect(result[1]).to.equal(hex2)\n            })\n        })\n\n        describe('containing valid hexes and other types', function() {\n            it('returns a grid instance with only the valid hexes', function() {\n                const hex1 = Hex()\n                const hex2 = Hex(2, -4)\n                const result = GridFactory([null, 'string', hex1, {}, hex2, 1])\n\n                expect(result).to.have.lengthOf(2)\n                expect(result[0]).to.equal(hex1)\n                expect(result[1]).to.equal(hex2)\n            })\n        })\n    })\n})\n",
    "static": true,
    "longname": "/Users/abbe/Projects/honeycomb/src/grid/index.spec.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 66,
    "kind": "variable",
    "name": "extendHex",
    "memberof": "src/grid/index.spec.js",
    "static": true,
    "longname": "src/grid/index.spec.js~extendHex",
    "access": "public",
    "export": false,
    "importPath": "honeycomb-grid/src/grid/index.spec.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 11,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 67,
    "kind": "variable",
    "name": "defineGrid",
    "memberof": "src/grid/index.spec.js",
    "static": true,
    "longname": "src/grid/index.spec.js~defineGrid",
    "access": "public",
    "export": false,
    "importPath": "honeycomb-grid/src/grid/index.spec.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 12,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 68,
    "kind": "variable",
    "name": "Hex",
    "memberof": "src/grid/index.spec.js",
    "static": true,
    "longname": "src/grid/index.spec.js~Hex",
    "access": "public",
    "export": false,
    "importPath": "honeycomb-grid/src/grid/index.spec.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 13,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 69,
    "kind": "file",
    "name": "src/grid/prototype.js",
    "content": "import { isString, isNumber } from 'axis.js'\n\nimport { DIRECTION_COORDINATES, DIAGONAL_DIRECTION_COORDINATES } from '../hex/constants'\n\n/**\n * Get a hex from a grid.\n *\n * @memberof Grid#\n * @instance\n *\n * @param {(number|point)} keyOrPoint   An index/key or a point.\n * @returns {hex}                       The found hex or `undefined`.\n *\n * @example\n * const Grid = Honeycomb.defineGrid()\n * const Hex = Grid.Hex\n * const grid = Grid.rectangle({ width: 2, height: 2 })\n *\n * grid.get(0)              // { x: 0, y: 0 }\n * grid.get(Hex(0, 1))      // { x: 0, y: 1 }\n * grid.get({ x: 0, y: 1 }) // { x: 0, y: 1 }\n * grid.get([0, 1])         // { x: 0, y: 1 }\n *\n * grid.get(42)             // undefined\n * grid.get(Hex(6, -2))     // undefined\n */\nexport function get(keyOrPoint) {\n    if (isNumber(keyOrPoint)) {\n        return this[keyOrPoint]\n    } else {\n        return this[this.indexOf(keyOrPoint)]\n    }\n}\n\nexport function setFactory({ Grid }) {\n    /**\n     * Replace a hex with another hex. This is a safe alternative to using bracket notation (`grid[0] = 'invalid'`).\n     *\n     * If the target hex isn't present in the grid, the new hex is added (using {@link Grid#push}) to the grid.\n     * If the new hex is invalid, nothing changes.\n     *\n     * @memberof Grid#\n     * @instance\n     *\n     * @param {(number|point)} keyOrPoint   The coordinates of the hex that must be replaced.\n     * @param {hex} newHex                  The replacing hex.\n     *\n     * @returns {grid}                      Itself.\n     *\n     * @example\n     * const Grid = Honeycomb.defineGrid()\n     * const Hex = Grid.Hex\n     * const grid = Grid(Hex(0, 0)) // [ { x: 0, y: 0 } ]\n     *\n     * // replace a hex:\n     * grid.set(0, Hex(1, 1))\n     * grid                         // [ { x: 1, y: 1 } ]\n     * // the target hex can also be a point:\n     * grid.set([1, 1], Hex(2, 2))\n     * grid                         // [ { x: 2, y: 2 } ]\n     *\n     * // invalid replace values are ignored:\n     * grid.set(0, 'invalid')\n     * grid                         // [ { x: 2, y: 2 } ]\n     *\n     * // when the target hex isn't present in the grid, the replacing hex is added instead:\n     * grid.set({ x: 9, y: 9 }, Hex(3, 3))\n     * grid                         // [ { x: 2, y: 2 }, { x: 3, y: 3 } ]\n     */\n    return function set(keyOrPoint, newHex) {\n        if (!Grid.isValidHex(newHex)) {\n            return this\n        }\n\n        const index = isNumber(keyOrPoint) ? keyOrPoint : this.indexOf(keyOrPoint)\n\n        if (index < 0) {\n            this.push(newHex)\n        } else {\n            this[index] = newHex\n        }\n\n        return this\n    }\n}\n\n/**\n * @memberof Grid#\n * @see {@link https://www.redblobgames.com/grids/hexagons/#line-drawing|redblobgames.com}\n *\n * @param {hex} firstHex    The first hex.\n * @param {hex} lastHex     The last hex.\n *\n * @returns {hex[]}         Array (not a {@link grid}) of hexes in a straight line from `firstHex` to (and including) `lastHex`.\n *\n * @example\n * const Grid = Honeycomb.defineGrid()\n * const Hex = Grid.Hex\n * const grid = Grid.rectangle({ width: 4, height: 4 })\n *\n * grid.hexesBetween(Hex(), Hex(3)) // [\n *                                  //    { x: 0, y: 0 },\n *                                  //    { x: 0, y: 1 },\n *                                  //    { x: 1, y: 1 },\n *                                  //    { x: 2, y: 2 },\n *                                  //    { x: 3, y: 2 },\n *                                  //    { x: 3, y: 3 },\n *                                  // ]\n */\nexport function hexesBetween(firstHex, lastHex) {\n    const distance = firstHex.distance(lastHex)\n    const step = 1.0 / Math.max(distance, 1)\n    let hexes = []\n\n    for (let i = 0; i <= distance; i++) {\n        const hex = firstHex.nudge().lerp(lastHex.nudge(), step * i).round()\n        hexes.push(this.get(hex))\n    }\n\n    return hexes\n}\n\n/**\n * @private\n */\nexport function neighborsOfFactory({ Grid, signedModulo, compassToNumberDirection }) {\n    /**\n     * @memberof Grid#\n     * @instance\n     * @see {@link https://www.redblobgames.com/grids/hexagons/#neighbors|redblobgames.com}\n     *\n     * @param {hex} hex\n     * A hex to get 1 or more neighbors from.\n     * @param {((COMPASS_DIRECTION|number)[]|COMPASS_DIRECTION|number|all)} [directions=all]\n     * 1 or more directions. Either (an array of) {@link COMPASS_DIRECTION|compass directions} or numbers or the string `'all'`.\n     * @param {boolean} [diagonal=false]\n     * Whether to get the diagonal neighbor. See {@link https://www.redblobgames.com/grids/hexagons/#neighbors-diagonal|redblobgames.com}.\n     *\n     * @returns {hex[]}\n     * An array of 0 up to 6 neighboring hexes. Only hexes that are present in the grid are returned.\n     *\n     * @throws {Error} When no valid hex is passed.\n     * @throws {Error} When the direction is invalid for the hex.\n     *\n     * @example\n     * const Hex = Honeycomb.extendHex({ orientation: 'pointy' })\n     * const Grid = Honeycomb.defineGrid(Hex)\n     * // conveniently creates a grid consisting of a hex surrounded by 6 hexes:\n     * const grid = Grid.hexagon({ radius: 1 })\n     *\n     * // all neighbors:\n     * grid.neighborsOf(Hex())          // [\n     *                                  //    { x: 1, y: 0 },\n     *                                  //    { x: 0, y: 1 },\n     *                                  //    { x: -1, y: 1 },\n     *                                  //    { x: -1, y: 0 },\n     *                                  //    { x: -1, y: -1 },\n     *                                  //    { x: 0, y: -1 },\n     *                                  // ]\n     * // specific neighbor:\n     * grid.neighborsOf(Hex(), 'NW')    // [{ x: -1, y: -1 }]\n     * grid.neighborsOf(Hex(), 4)       // [{ x: -1, y: -1 }]\n     *\n     * // multiple neighbors:\n     * grid.neighborsOf(Hex(), ['SE', 'SW'])    // [\n     *                                          //    { x: 0, y: 1 },\n     *                                          //    { x: -1, y: 1 }\n     *                                          // ]\n     *\n     * grid.neighborsOf(Hex(), [1, 2])          // [\n     *                                          //    { x: 0, y: 1 },\n     *                                          //    { x: -1, y: 1 }\n     *                                          // ]\n     * // diagonal neighbor:\n     * grid.neighborsOf(Hex(-1, 0), 'E', true)  // [{ x: 0, y: -1 }]\n     *\n     * // only returns hexes that exist in the grid:\n     * grid.neighborsOf(Hex(-1, -1), 'NW')      // []\n     */\n    return function neighborsOf(hex, directions = 'all', diagonal = false) {\n        if (!Grid.isValidHex(hex)) {\n            throw new Error(`Invalid hex: ${hex}.`)\n        }\n\n        const coordinates = diagonal ? DIAGONAL_DIRECTION_COORDINATES : DIRECTION_COORDINATES\n\n        if (directions === 'all') {\n            directions = [0, 1, 2, 3, 4, 5]\n        }\n\n        return directions = []\n            // ensure directions is an array\n            .concat(directions)\n            .map(direction => {\n                // todo: move this to a util, also grid/statics.js#277\n                if (isString(direction)) {\n                    direction = compassToNumberDirection(direction, hex.orientation)\n                }\n\n                if (direction < 0 || direction > 5) {\n                    direction = signedModulo(direction, 6)\n                }\n\n                const { q, r } = coordinates[direction]\n                return this.get(hex.cubeToCartesian({ q: hex.q + q, r: hex.r + r }))\n            })\n            .filter(Boolean)\n    }\n}\n",
    "static": true,
    "longname": "/Users/abbe/Projects/honeycomb/src/grid/prototype.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 70,
    "kind": "function",
    "name": "get",
    "memberof": "src/grid/prototype.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/grid/prototype.js~get",
    "access": "public",
    "export": true,
    "importPath": "honeycomb-grid/src/grid/prototype.js",
    "importStyle": "{get}",
    "description": "Get a hex from a grid.",
    "examples": [
      "const Grid = Honeycomb.defineGrid()\nconst Hex = Grid.Hex\nconst grid = Grid.rectangle({ width: 2, height: 2 })\n\ngrid.get(0)              // { x: 0, y: 0 }\ngrid.get(Hex(0, 1))      // { x: 0, y: 1 }\ngrid.get({ x: 0, y: 1 }) // { x: 0, y: 1 }\ngrid.get([0, 1])         // { x: 0, y: 1 }\n\ngrid.get(42)             // undefined\ngrid.get(Hex(6, -2))     // undefined"
    ],
    "lineNumber": 27,
    "unknown": [
      {
        "tagName": "@instance",
        "tagValue": ""
      },
      {
        "tagName": "@returns",
        "tagValue": "{hex}                       The found hex or `undefined`."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number",
          "point"
        ],
        "spread": false,
        "optional": false,
        "name": "keyOrPoint",
        "description": "An index/key or a point."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "hex"
      ],
      "spread": false,
      "description": "The found hex or `undefined`."
    }
  },
  {
    "__docId__": 71,
    "kind": "function",
    "name": "setFactory",
    "memberof": "src/grid/prototype.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/grid/prototype.js~setFactory",
    "access": "public",
    "export": true,
    "importPath": "honeycomb-grid/src/grid/prototype.js",
    "importStyle": "{setFactory}",
    "description": null,
    "lineNumber": 35,
    "undocument": true,
    "params": [
      {
        "name": "objectPattern",
        "types": [
          "{\"Grid\": *}"
        ],
        "defaultRaw": {
          "Grid": null
        },
        "defaultValue": "{\"Grid\":null}"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 72,
    "kind": "function",
    "name": "hexesBetween",
    "memberof": "src/grid/prototype.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/grid/prototype.js~hexesBetween",
    "access": "public",
    "export": true,
    "importPath": "honeycomb-grid/src/grid/prototype.js",
    "importStyle": "{hexesBetween}",
    "description": "",
    "examples": [
      "const Grid = Honeycomb.defineGrid()\nconst Hex = Grid.Hex\nconst grid = Grid.rectangle({ width: 4, height: 4 })\n\ngrid.hexesBetween(Hex(), Hex(3)) // [\n                                 //    { x: 0, y: 0 },\n                                 //    { x: 0, y: 1 },\n                                 //    { x: 1, y: 1 },\n                                 //    { x: 2, y: 2 },\n                                 //    { x: 3, y: 2 },\n                                 //    { x: 3, y: 3 },\n                                 // ]"
    ],
    "see": [
      "{@link https://www.redblobgames.com/grids/hexagons/#line-drawing|redblobgames.com}"
    ],
    "lineNumber": 110,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{hex[]}         Array (not a {@link grid}) of hexes in a straight line from `firstHex` to (and including) `lastHex`."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "hex"
        ],
        "spread": false,
        "optional": false,
        "name": "firstHex",
        "description": "The first hex."
      },
      {
        "nullable": null,
        "types": [
          "hex"
        ],
        "spread": false,
        "optional": false,
        "name": "lastHex",
        "description": "The last hex."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "hex[]"
      ],
      "spread": false,
      "description": "Array (not a {@link grid}) of hexes in a straight line from `firstHex` to (and including) `lastHex`."
    }
  },
  {
    "__docId__": 73,
    "kind": "function",
    "name": "neighborsOfFactory",
    "memberof": "src/grid/prototype.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/grid/prototype.js~neighborsOfFactory",
    "access": "private",
    "export": true,
    "importPath": "honeycomb-grid/src/grid/prototype.js",
    "importStyle": "{neighborsOfFactory}",
    "description": "",
    "lineNumber": 126,
    "ignore": true,
    "params": [
      {
        "name": "objectPattern",
        "types": [
          "{\"Grid\": *, \"signedModulo\": *, \"compassToNumberDirection\": *}"
        ],
        "defaultRaw": {
          "Grid": null,
          "signedModulo": null,
          "compassToNumberDirection": null
        },
        "defaultValue": "{\"Grid\":null,\"signedModulo\":null,\"compassToNumberDirection\":null}"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 74,
    "kind": "file",
    "name": "src/grid/prototype.spec.js",
    "content": "/* eslint-env mocha */\n\nimport { expect } from 'chai'\nimport sinon from 'sinon'\n\nimport { ensureXY, signedModulo, compassToNumberDirection } from '../utils'\nimport extendHexFactory from '../hex'\nimport defineGridFactory from './'\nimport * as methods from './prototype'\n\nconst extendHex = extendHexFactory({ ensureXY })\nconst Hex = extendHex()\nconst GridFactory = defineGridFactory({ extendHex })(Hex)\n\ndescribe('get', () => {\n    it('accepts a number or a point', () => {\n        const targetHex = Hex(3, -2)\n        const grid = GridFactory(targetHex)\n\n        expect(grid.get(0)).to.equal(targetHex)\n        expect(grid.get(Hex(3, -2))).to.equal(targetHex)\n        expect(grid.get([3, -2])).to.equal(targetHex)\n    })\n\n    describe('when not present in the grid', () => {\n        it('returns the passed hex', () => {\n            const targetHex = Hex(3, -2)\n            const grid = GridFactory(targetHex)\n\n            expect(grid.get(Hex())).to.be.undefined\n        })\n    })\n})\n\ndescribe('set', () => {\n    let set, isValidHex, targetHex, newHex, grid\n\n    beforeEach(() => {\n        isValidHex = sinon.stub().returns(true)\n        set = methods.setFactory({ Grid: { isValidHex } })\n        targetHex = Hex(3, -2)\n        newHex = Hex(1, 1)\n        grid = GridFactory(targetHex)\n    })\n\n    it('accepts a number as the first parameter', () => {\n        expect(grid.set(0, newHex)).to.have.lengthOf(1)\n            .and.contain.hexes([newHex])\n    })\n\n    it('accepts a point as the first parameter', () => {\n        expect(grid.set([3, -2], newHex)).to.have.lengthOf(1)\n            .and.contain.hexes([newHex])\n    })\n\n    describe('when the hex that must be replaced is present in the grid', () => {\n        it('replaces the hex with the new hex and returns the updated grid', () => {\n            const result = set.call(grid, targetHex, newHex)\n\n            expect(result).to.have.lengthOf(1)\n                .and.contain.hexes([newHex])\n                .and.not.contain.hexes([targetHex])\n            expect(grid).to.eql(result)\n        })\n\n        describe('when the new hex is invalid', () => {\n            it('does not replace the hex and returns the grid', () => {\n                isValidHex.returns(false)\n                const newHex = 'invalid hex'\n                expect(set.call(grid, targetHex, newHex)).to.eql(grid)\n            })\n        })\n    })\n\n    describe('when the hex that must be replaced is not present in the grid', () => {\n        it(`pushes the new hex and returns the grid`, () => {\n            const startHex = Hex(-9, 9)\n            const grid = GridFactory(startHex)\n            const result = set.call(grid, targetHex, newHex)\n\n            expect(result).to.have.lengthOf(2)\n                .and.contain.hexes([startHex, newHex])\n                .and.not.contain.hexes([targetHex])\n            expect(grid).to.eql(result)\n        })\n\n        describe('when the new hex is invalid', () => {\n            it('does not push the new hex and returns the grid', () => {\n                isValidHex.returns(false)\n                const startHex = Hex(-9, 9)\n                const newHex = 'invalid hex'\n                const grid = GridFactory(startHex)\n\n                expect(set.call(grid, targetHex, newHex)).to.eql(grid)\n            })\n        })\n    })\n})\n\ndescribe('hexesBetween', () => {\n    it('calls the passed firstHex.distance()', () => {\n        const distance = sinon.stub()\n        const firstHex = { distance }\n        const lastHex = 'last hex'\n        methods.hexesBetween(firstHex, lastHex)\n\n        expect(distance).to.have.been.calledWith(lastHex)\n    })\n\n    it('calls firstHex.nudge(), firstHex.lerp(), lastHex.nudge() and firstHex.round() for each hex between firstHex and lastHex', () => {\n        const round = sinon.stub().returns('round result')\n        const lerp = sinon.stub().returns({ round })\n        const firstHexNudge = sinon.stub().returns({ lerp })\n        const lastHexNudge = sinon.stub().returns('last hex nudge result')\n        const distance = sinon.stub().returns(2)\n        const firstHex = { distance, nudge: firstHexNudge }\n        const lastHex = { nudge: lastHexNudge }\n        const get = sinon.stub().returns('get result')\n        const hexesBetween = methods.hexesBetween.bind({ get })\n        const result = hexesBetween(firstHex, lastHex)\n\n        expect(firstHexNudge).to.have.callCount(3)\n        expect(lerp).to.have.callCount(3)\n        expect(lerp).to.always.have.been.calledWith('last hex nudge result', sinon.match.number)\n        expect(lastHexNudge).to.have.callCount(3)\n        expect(round).to.have.callCount(3)\n        expect(get).to.have.callCount(3)\n        expect(get).to.always.have.been.calledWith('round result')\n        expect(result).to.eql(['get result', 'get result', 'get result'])\n    })\n\n    describe('when all hexes between firstHex and lastHex are present in the grid', () => {\n        it('returns the hexes in a straight line, inclusive', () => {\n            const grid = GridFactory.rectangle({ width: 4, height: 2 })\n            const result = grid.hexesBetween(Hex(), Hex(3, 1))\n\n            expect(result).to.be.an('array').that.has.a.lengthOf(5)\n            expect(result[0]).to.equal(grid[0])\n            expect(result[1]).to.equal(grid[1])\n            expect(result[2]).to.equal(grid[2])\n            expect(result[3]).to.equal(grid[6])\n            expect(result[4]).to.equal(grid[7])\n        })\n    })\n\n    describe('when some hexes between firstHex and lastHex are missing in the grid', () => {\n        it('returns any present hexes in a straight line, inclusive', () => {\n            const grid = GridFactory.rectangle({ width: 3, height: 2 })\n            const firstHex = Hex()\n            const lastHex = Hex(3, 1)\n            const result = grid.hexesBetween(firstHex, lastHex)\n\n            expect(result).to.be.an('array').that.has.a.lengthOf(5)\n            expect(result[0]).to.equal(grid[0])\n            expect(result[1]).to.equal(grid[1])\n            expect(result[2]).to.equal(grid[2])\n            expect(result[3]).to.equal(grid[5])\n            expect(result[4]).to.be.undefined\n        })\n    })\n})\n\ndescribe('neighborsOf', () => {\n    let neighborsOf, isValidHex, signedModuloSpy, compassToNumberDirectionSpy, cubeToCartesian, hex, get\n\n    beforeEach(() => {\n        isValidHex = sinon.stub().returns(true)\n        signedModuloSpy = sinon.spy(signedModulo)\n        compassToNumberDirectionSpy = sinon.spy(compassToNumberDirection)\n        cubeToCartesian = sinon.stub().returns('cubeToCartesian result')\n        hex = { cubeToCartesian, q: 1, r: 1 }\n        get = sinon.spy()\n        neighborsOf = methods.neighborsOfFactory({\n            Grid: { isValidHex },\n            signedModulo: signedModuloSpy,\n            compassToNumberDirection: compassToNumberDirectionSpy\n        }).bind({ get })\n    })\n\n    afterEach(() => {\n        cubeToCartesian.reset()\n    })\n\n    it('throws when no hex is passed', () => {\n        isValidHex.returns(false)\n        expect(() => neighborsOf()).to.throw(`Invalid hex: undefined.`)\n    })\n\n    it('accepts 3 parameters', () => {\n        neighborsOf(hex, [2, 4], true)\n        expect(cubeToCartesian.getCall(0)).to.have.been.calledWith({ q: 0, r: 3 })\n        expect(cubeToCartesian.getCall(1)).to.have.been.calledWith({ q: 0, r: 0 })\n    })\n\n    it('calls grid.get() with the result of hex.cubeToCartesian() for each direction', () => {\n        neighborsOf(hex)\n        expect(get.callCount).to.equal(6)\n        expect(get).to.always.have.been.calledWith('cubeToCartesian result')\n    })\n\n    describe(`when called with no direction or 'all' directions`, () => {\n        it(`calls the passed hex.cubeToCartesian() with the sum of the passed hex's cube coordinates and all direction coordinates`, () => {\n            neighborsOf(hex)\n            expect(cubeToCartesian.getCall(0).args[0]).to.eql({ q: 2, r: 1 })\n            expect(cubeToCartesian.getCall(1).args[0]).to.eql({ q: 1, r: 2 })\n            expect(cubeToCartesian.getCall(2).args[0]).to.eql({ q: 0, r: 2 })\n            expect(cubeToCartesian.getCall(3).args[0]).to.eql({ q: 0, r: 1 })\n            expect(cubeToCartesian.getCall(4).args[0]).to.eql({ q: 1, r: 0 })\n            expect(cubeToCartesian.getCall(5).args[0]).to.eql({ q: 2, r: 0 })\n\n            cubeToCartesian.reset()\n\n            neighborsOf(hex, 'all')\n            expect(cubeToCartesian.getCall(0).args[0]).to.eql({ q: 2, r: 1 })\n            expect(cubeToCartesian.getCall(1).args[0]).to.eql({ q: 1, r: 2 })\n            expect(cubeToCartesian.getCall(2).args[0]).to.eql({ q: 0, r: 2 })\n            expect(cubeToCartesian.getCall(3).args[0]).to.eql({ q: 0, r: 1 })\n            expect(cubeToCartesian.getCall(4).args[0]).to.eql({ q: 1, r: 0 })\n            expect(cubeToCartesian.getCall(5).args[0]).to.eql({ q: 2, r: 0 })\n        })\n    })\n\n    describe('when called with directions outside 0..5', () => {\n        it(`passed them to signedModulo`, () => {\n            neighborsOf(hex, -1)\n            expect(signedModuloSpy).to.have.been.calledWith(-1, 6)\n\n            signedModuloSpy.reset()\n\n            neighborsOf(hex, 3)\n            expect(signedModuloSpy).not.to.have.been.called\n        })\n    })\n\n    describe('when called with a single number direction', () => {\n        it(`calls the passed hex.cubeToCartesian() with the sum of the passed hex's cube coordinates and the passed direction coordinate`, () => {\n            neighborsOf(hex, 2)\n            expect(cubeToCartesian.callCount).to.equal(1)\n            expect(cubeToCartesian.getCall(0).args[0]).to.eql({ q: 0, r: 2 })\n        })\n    })\n\n    describe('when called with compass direction(s)', () => {\n        it('calls compassToNumberDirection', () => {\n            hex.orientation = 'pointy'\n            neighborsOf(hex, 'NW')\n\n            expect(compassToNumberDirectionSpy).to.have.been.calledWith('NW', 'pointy')\n        })\n    })\n\n    describe('with the diagonal flag enabled', () => {\n        it(`calls the passed hex.cubeToCartesian() with the sum of the passed hex's cube coordinates and all direction coordinates`, () => {\n            neighborsOf(hex, 'all', true)\n            expect(cubeToCartesian.getCall(0).args[0]).to.eql({ q: 3, r: 0 })\n            expect(cubeToCartesian.getCall(1).args[0]).to.eql({ q: 2, r: 2 })\n            expect(cubeToCartesian.getCall(2).args[0]).to.eql({ q: 0, r: 3 })\n            expect(cubeToCartesian.getCall(3).args[0]).to.eql({ q: -1, r: 2 })\n            expect(cubeToCartesian.getCall(4).args[0]).to.eql({ q: 0, r: 0 })\n            expect(cubeToCartesian.getCall(5).args[0]).to.eql({ q: 2, r: -1 })\n        })\n    })\n\n    describe('when all neighbors are present in the grid', () => {\n        it('returns all neighbors', () => {\n            const grid = GridFactory.hexagon({ radius: 1 })\n            const result = grid.neighborsOf(Hex())\n\n            expect(result).to.be.an('array').that.has.a.lengthOf(6)\n            expect(result[0]).to.equal(grid[6])\n            expect(result[1]).to.equal(grid[4])\n            expect(result[2]).to.equal(grid[1])\n            expect(result[3]).to.equal(grid[0])\n            expect(result[4]).to.equal(grid[2])\n            expect(result[5]).to.equal(grid[5])\n        })\n    })\n\n    describe('when some neighbors are present in the grid', () => {\n        it('returns only the present neighbors', () => {\n            const grid = GridFactory.hexagon({ radius: 1 })\n            const hex = Hex(1, 0)\n            const result = grid.neighborsOf(hex)\n\n            expect(result).to.be.an('array').that.has.a.lengthOf(3)\n            expect(result[0]).to.equal(grid[4])\n            expect(result[1]).to.equal(grid[3])\n            expect(result[2]).to.equal(grid[5])\n        })\n    })\n})\n",
    "static": true,
    "longname": "/Users/abbe/Projects/honeycomb/src/grid/prototype.spec.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 75,
    "kind": "variable",
    "name": "extendHex",
    "memberof": "src/grid/prototype.spec.js",
    "static": true,
    "longname": "src/grid/prototype.spec.js~extendHex",
    "access": "public",
    "export": false,
    "importPath": "honeycomb-grid/src/grid/prototype.spec.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 11,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 76,
    "kind": "variable",
    "name": "Hex",
    "memberof": "src/grid/prototype.spec.js",
    "static": true,
    "longname": "src/grid/prototype.spec.js~Hex",
    "access": "public",
    "export": false,
    "importPath": "honeycomb-grid/src/grid/prototype.spec.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 12,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 77,
    "kind": "variable",
    "name": "GridFactory",
    "memberof": "src/grid/prototype.spec.js",
    "static": true,
    "longname": "src/grid/prototype.spec.js~GridFactory",
    "access": "public",
    "export": false,
    "importPath": "honeycomb-grid/src/grid/prototype.spec.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 13,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 78,
    "kind": "file",
    "name": "src/grid/statics.js",
    "content": "import { isString } from 'axis.js'\nimport { offsetFromZero } from '../utils'\n\n/**\n * @ignore\n */\nexport function isValidHexFactory({ Grid }) {\n    /**\n     * @memberof Grid\n     * @static\n     * @method\n     *\n     * @param {*} value     Any value.\n     * @returns {boolean}   Whether the passed value is a valid hex.\n     */\n    return function isValidHex(value) {\n        return Grid.isValidHex(value)\n    }\n}\n\n/**\n * @private\n */\nexport function pointToHexFactory({ Point, Hex }) {\n    /**\n     * Converts the passed {@link point} to a hex.\n     *\n     * @memberof Grid\n     * @static\n     * @method\n     * @see {@link https://www.redblobgames.com/grids/hexagons/#pixel-to-hex|redblobgames.com}\n     *\n     * @param {point} point The point to convert from.\n     * @returns {hex}       A hex (with rounded coordinates) that contains the passed point.\n     *\n     * @example\n     * const Hex = Honeycomb.extendHex({ size: 50 })\n     * const Grid = Honeycomb.defineGrid(Hex)\n     *\n     * Grid.pointToHex({ x: 120, y: 280 })  // { x: 1, y: 4 }\n     * Grid.pointToHex([ 120, 280 ])        // { x: 1, y: 4 }\n     *\n     * const Point = Honeycomb.Point\n     * Grid.pointToHex(Point(120, 280))     // { x: 1, y: 4 }\n     */\n    return function pointToHex(point) {\n        const hex = Hex()\n        const size = hex.size\n        const { x, y } = Point(point).subtract(hex.center())\n        let q, r\n\n        if (hex.isPointy()) {\n            q = (x * Math.sqrt(3) / 3 - y / 3) / size\n            r = y * 2 / 3 / size\n        } else {\n            q = x * 2 / 3 / size\n            r = (-x / 3 + Math.sqrt(3) / 3 * y) / size\n        }\n\n        return Hex({q, r, s: -q - r }).round()\n    }\n}\n\n/**\n * @private\n */\nexport function parallelogramFactory({ Grid, Hex }) {\n    /**\n     * Creates a grid in the shape of a [parallelogram](https://en.wikipedia.org/wiki/Parallelogram) ▱.\n     *\n     * @memberof Grid\n     * @static\n     * @method\n     * @see {@link https://www.redblobgames.com/grids/hexagons/implementation.html#map-shapes|redblobgames.com}\n     *\n     * @todo Validate params\n     * @todo Move duplicate code to util\n     *\n     * @param {Object} options                      An options object.\n     * @param {number} options.width                The width (in hexes).\n     * @param {number} options.height               The height (in hexes).\n     * @param {hex} [options.start=Hex(0)]          The start hex.\n     * @param {(1|3|5)} [options.direction=1]       The direction (from the start hex) in which to create the shape.\n     *                                              Each direction corresponds to a different arrangement of hexes.\n     * @param {onCreate} [options.onCreate=no-op]   Callback that's called for each hex. Defaults to a {@link https://en.wikipedia.org/wiki/NOP|no-op}.\n     *\n     * @returns {grid}                              Grid of hexes in a parallelogram arrangement.\n     */\n    return function parallelogram({\n        width,\n        height,\n        start,\n        direction = 1,\n        /**\n         * Callback of a {@link Grid} shape method.\n         * Gets called for each hex that's about to be added to the grid.\n         *\n         * @callback onCreate\n         * @param {hex} hex     The freshly created hex, just before it's added to the grid.\n         * @param {grid} grid   The grid (for as far as it's created).\n         * @returns {void}      Nothing.\n         */\n        onCreate = () => { }\n    }) {\n        start = Hex(start)\n        // TODO: validate direction\n        const DIRECTIONS = {\n            1: ['q', 'r', 's'],\n            3: ['r', 's', 'q'],\n            5: ['s', 'q', 'r']\n        }\n        const [firstCoordinate, secondCoordinate, thirdCoordinate] = DIRECTIONS[direction]\n        const grid = new Grid()\n\n        for (let first = 0; first < width; first++) {\n            for (let second = 0; second < height; second++) {\n                const hex = Hex(start.cubeToCartesian({\n                    [firstCoordinate]: first + start[firstCoordinate],\n                    [secondCoordinate]: second + start[secondCoordinate],\n                    [thirdCoordinate]: -first - second + start[thirdCoordinate]\n                }))\n                onCreate(hex, grid)\n                grid.push(hex)\n            }\n        }\n\n        return grid\n    }\n}\n\n/**\n * @private\n */\nexport function triangleFactory({ Grid, Hex }) {\n    /**\n     * Creates a grid in the shape of a [(equilateral) triangle](https://en.wikipedia.org/wiki/Equilateral_triangle) △.\n     *\n     * @memberof Grid\n     * @static\n     * @method\n     * @see {@link https://www.redblobgames.com/grids/hexagons/implementation.html#map-shapes|redblobgames.com}\n     *\n     * @todo Validate params\n     * @todo Move duplicate code to util\n     *\n     * @param {Object} options                      An options object.\n     * @param {number} options.size                 The side length (in hexes).\n     * @param {hex} [options.start=Hex(0)]          The start hex. **Note**: it's not the first hex, but rather a hex relative to the triangle.\n     * @param {(1|5)} [options.direction=1]         The direction in which to create the shape. Each direction corresponds to a different arrangement of hexes. In this case a triangle pointing up (`direction: 1`) or down (`direction: 5`) (with pointy hexes) or right (`direction: 1`) or left (`direction: 5`) (with flat hexes).\n     *                                              Each direction corresponds to a different arrangement of hexes.\n     * @param {onCreate} [options.onCreate=no-op]   Callback that's called for each hex. Defaults to a {@link https://en.wikipedia.org/wiki/NOP|no-op}.\n     *\n     * @returns {grid}                              Grid of hexes in a triangle arrangement.\n     */\n    return function triangle({\n        size,\n        start,\n        direction = 1,\n        onCreate = () => { }\n    }) {\n        start = Hex(start)\n        // TODO: validate direction\n        const DIRECTIONS = {\n            1: {\n                rStart: () => 0,\n                rEnd: q => size - q\n            },\n            5: {\n                rStart: q => size - q,\n                rEnd: () => size + 1\n            }\n        }\n        const { rStart, rEnd } = DIRECTIONS[direction]\n        const grid = new Grid()\n\n        for (let q = 0; q < size; q++) {\n            for (let r = rStart(q); r < rEnd(q); r++) {\n                const hex = Hex(start.cubeToCartesian({\n                    q: q + start.q,\n                    r: r + start.r,\n                    s: -q - r + start.s\n                }))\n                onCreate(hex, grid)\n                grid.push(hex)\n            }\n        }\n\n        return grid\n    }\n}\n\n/**\n * @private\n */\nexport function hexagonFactory({ Grid, Hex }) {\n    /**\n     * Creates a grid in the shape of a [hexagon](https://en.wikipedia.org/wiki/Hexagon) ⬡.\n     *\n     * @memberof Grid\n     * @static\n     * @method\n     * @see {@link https://www.redblobgames.com/grids/hexagons/implementation.html#map-shapes|redblobgames.com}\n     *\n     * @todo Validate params\n     * @todo Move duplicate code to util\n     *\n     * @param {Object} options                      An options object.\n     * @param {number} options.radius               The radius (in hexes) *excluding* the center hex.\n     * @param {hex} [options.center=Hex(0)]         The center hex.\n     *                                              Each direction corresponds to a different arrangement of hexes.\n     * @param {onCreate} [options.onCreate=no-op]   Callback that's called for each hex. Defaults to a {@link https://en.wikipedia.org/wiki/NOP|no-op}.\n     *\n     * @returns {grid}                              Grid of hexes in a hexagon arrangement.\n     */\n    return function hexagon({\n        radius,\n        center,\n        onCreate = () => { }\n    }) {\n        center = Hex(center)\n\n        const grid = new Grid()\n\n        for (let q = -radius; q <= radius; q++) {\n            const startR = Math.max(-radius, -q - radius)\n            const endR = Math.min(radius, -q + radius)\n\n            for (let r = startR; r <= endR; r++) {\n                const hex = Hex(center.cubeToCartesian({\n                    q: q + center.q,\n                    r: r + center.r,\n                    s: -q - r + center.s\n                }))\n                onCreate(hex, grid)\n                grid.push(hex)\n            }\n        }\n\n        return grid\n    }\n}\n\n/**\n * @private\n */\nexport function rectangleFactory({ Grid, Hex, compassToNumberDirection, signedModulo }) {\n    /**\n     * Creates a grid in the shape of a [rectangle](https://en.wikipedia.org/wiki/Rectangle) ▭.\n     *\n     * @memberof Grid\n     * @static\n     * @method\n     * @see {@link https://www.redblobgames.com/grids/hexagons/implementation.html#map-shapes|redblobgames.com}\n     *\n     * @todo Validate params\n     * @todo Move duplicate code to util\n     *\n     * @param {Object} options                      An options object.\n     * @param {number} options.width                The width (in hexes).\n     * @param {number} options.height               The height (in hexes).\n     * @param {hex} [options.start=Hex(0)]          The start hex.\n     * @param {(COMPASS_DIRECTION|number)} [options.direction=E|S]\n     * The direction (from the start hex) in which to create the shape.\n     * Defaults to `0` (`E`) for pointy hexes and `1` (`S`) for flat hexes.\n     * Each direction corresponds to a different arrangement of hexes.\n     * @param {onCreate} [options.onCreate=no-op]   Callback that's called for each hex. Defaults to a {@link https://en.wikipedia.org/wiki/NOP|no-op}.\n     *\n     * @returns {grid}                              Grid of hexes in a rectangular arrangement.\n     */\n    return function rectangle({\n        width,\n        height,\n        start,\n        direction = Hex().isPointy() ? 0 : 1, // E or S\n        onCreate = () => { }\n    }) {\n        start = Hex(start)\n\n        if (isString(direction)) {\n            direction = compassToNumberDirection(direction, start.orientation)\n        }\n\n        if (direction < 0 || direction > 5) {\n            direction = signedModulo(direction, 6)\n        }\n\n        const DIRECTIONS = [\n            ['q', 'r', 's'],\n            ['r', 'q', 's'],\n            ['r', 's', 'q'],\n            ['s', 'r', 'q'],\n            ['s', 'q', 'r'],\n            ['q', 's', 'r']\n        ]\n        const [firstCoordinate, secondCoordinate, thirdCoordinate] = DIRECTIONS[direction]\n        const [firstStop, secondStop] = start.isPointy() ? [width, height] : [height, width]\n        const grid = new Grid()\n\n        for (let second = 0; second < secondStop; second++) {\n            const secondOffset = offsetFromZero(start.offset, second)\n\n            for (let first = -secondOffset; first < firstStop - secondOffset; first++) {\n                const hex = Hex(start.cubeToCartesian({\n                    [firstCoordinate]: first + start[firstCoordinate],\n                    [secondCoordinate]: second + start[secondCoordinate],\n                    [thirdCoordinate]: -first - second + start[thirdCoordinate]\n                }))\n                onCreate(hex, grid)\n                grid.push(hex)\n            }\n        }\n\n        return grid\n    }\n}\n",
    "static": true,
    "longname": "/Users/abbe/Projects/honeycomb/src/grid/statics.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 79,
    "kind": "function",
    "name": "isValidHexFactory",
    "memberof": "src/grid/statics.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/grid/statics.js~isValidHexFactory",
    "access": "public",
    "export": true,
    "importPath": "honeycomb-grid/src/grid/statics.js",
    "importStyle": "{isValidHexFactory}",
    "description": "",
    "lineNumber": 7,
    "ignore": true,
    "params": [
      {
        "name": "objectPattern",
        "types": [
          "{\"Grid\": *}"
        ],
        "defaultRaw": {
          "Grid": null
        },
        "defaultValue": "{\"Grid\":null}"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 80,
    "kind": "function",
    "name": "pointToHexFactory",
    "memberof": "src/grid/statics.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/grid/statics.js~pointToHexFactory",
    "access": "private",
    "export": true,
    "importPath": "honeycomb-grid/src/grid/statics.js",
    "importStyle": "{pointToHexFactory}",
    "description": "",
    "lineNumber": 24,
    "ignore": true,
    "params": [
      {
        "name": "objectPattern",
        "types": [
          "{\"Point\": *, \"Hex\": *}"
        ],
        "defaultRaw": {
          "Point": null,
          "Hex": null
        },
        "defaultValue": "{\"Point\":null,\"Hex\":null}"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 81,
    "kind": "function",
    "name": "parallelogramFactory",
    "memberof": "src/grid/statics.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/grid/statics.js~parallelogramFactory",
    "access": "private",
    "export": true,
    "importPath": "honeycomb-grid/src/grid/statics.js",
    "importStyle": "{parallelogramFactory}",
    "description": "",
    "lineNumber": 67,
    "ignore": true,
    "params": [
      {
        "name": "objectPattern",
        "types": [
          "{\"Grid\": *, \"Hex\": *}"
        ],
        "defaultRaw": {
          "Grid": null,
          "Hex": null
        },
        "defaultValue": "{\"Grid\":null,\"Hex\":null}"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 82,
    "kind": "function",
    "name": "triangleFactory",
    "memberof": "src/grid/statics.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/grid/statics.js~triangleFactory",
    "access": "private",
    "export": true,
    "importPath": "honeycomb-grid/src/grid/statics.js",
    "importStyle": "{triangleFactory}",
    "description": "",
    "lineNumber": 134,
    "ignore": true,
    "params": [
      {
        "name": "objectPattern",
        "types": [
          "{\"Grid\": *, \"Hex\": *}"
        ],
        "defaultRaw": {
          "Grid": null,
          "Hex": null
        },
        "defaultValue": "{\"Grid\":null,\"Hex\":null}"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 83,
    "kind": "function",
    "name": "hexagonFactory",
    "memberof": "src/grid/statics.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/grid/statics.js~hexagonFactory",
    "access": "private",
    "export": true,
    "importPath": "honeycomb-grid/src/grid/statics.js",
    "importStyle": "{hexagonFactory}",
    "description": "",
    "lineNumber": 195,
    "ignore": true,
    "params": [
      {
        "name": "objectPattern",
        "types": [
          "{\"Grid\": *, \"Hex\": *}"
        ],
        "defaultRaw": {
          "Grid": null,
          "Hex": null
        },
        "defaultValue": "{\"Grid\":null,\"Hex\":null}"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 84,
    "kind": "function",
    "name": "rectangleFactory",
    "memberof": "src/grid/statics.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/grid/statics.js~rectangleFactory",
    "access": "private",
    "export": true,
    "importPath": "honeycomb-grid/src/grid/statics.js",
    "importStyle": "{rectangleFactory}",
    "description": "",
    "lineNumber": 246,
    "ignore": true,
    "params": [
      {
        "name": "objectPattern",
        "types": [
          "{\"Grid\": *, \"Hex\": *, \"compassToNumberDirection\": *, \"signedModulo\": *}"
        ],
        "defaultRaw": {
          "Grid": null,
          "Hex": null,
          "compassToNumberDirection": null,
          "signedModulo": null
        },
        "defaultValue": "{\"Grid\":null,\"Hex\":null,\"compassToNumberDirection\":null,\"signedModulo\":null}"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 85,
    "kind": "file",
    "name": "src/grid/statics.spec.js",
    "content": "/* eslint-env mocha */\n\nimport { expect } from 'chai'\nimport sinon from 'sinon'\n\nimport { ensureXY, compassToNumberDirection, signedModulo } from '../utils'\nimport extendHexFactory from '../hex'\nimport Grid from './class'\nimport * as statics from './statics'\n\nconst extendHex = extendHexFactory({ ensureXY })\nconst Hex = extendHex()\n\ndescribe('isValidHex', () => {\n    it('calls Grid.isValidHex', () => {\n        sinon.spy(Grid, 'isValidHex')\n\n        const isValidHex = statics.isValidHexFactory({ Grid })\n        isValidHex('value')\n\n        expect(Grid.isValidHex).to.have.been.calledWith('value')\n\n        Grid.isValidHex.restore()\n    })\n})\n\ndescribe('pointToHex', function() {\n    let subtract, Point, isPointy, hexResult, Hex, round, center, pointToHex, point\n\n    beforeEach(function() {\n        point = { x: 1, y: 1 }\n        subtract = sinon.stub().returns(point)\n        Point = sinon.stub().returns({ subtract })\n        isPointy = sinon.stub()\n        round = sinon.stub().returns('round result')\n        center = sinon.stub().returns('center result')\n        hexResult = {\n            size: 1,\n            isPointy,\n            round,\n            center\n        }\n        Hex = sinon.stub().returns(hexResult)\n        pointToHex = statics.pointToHexFactory({ Point, Hex })\n    })\n\n    it('calls Hex to access its size, center and isPointy', function() {\n        pointToHex(point)\n        expect(Hex).to.have.been.called\n    })\n\n    it('calls Point with the passed point to convert it to an actual point', function() {\n        pointToHex(point)\n        expect(Point).to.have.been.calledWith(point)\n    })\n\n    it(`subtracts the hex's center from the point`, function() {\n        pointToHex(point)\n        expect(center).to.have.been.called\n        expect(subtract).to.have.been.calledWith('center result')\n    })\n\n    describe('when the hex has a pointy orientation', function() {\n        beforeEach(function() {\n            isPointy.returns(true)\n        })\n\n        it('creates a new hex', function() {\n            pointToHex(point)\n            expect(Hex.secondCall.args[0].q).to.be.closeTo(0.2440, 0.0005)\n            expect(Hex.secondCall.args[0].r).to.be.closeTo(0.6667, 0.0005)\n        })\n    })\n\n    describe('when the hex has a flat orientation', function() {\n        beforeEach(function() {\n            isPointy.returns(false)\n        })\n\n        it('creates a new hex', function() {\n            pointToHex(point)\n            expect(Hex.secondCall.args[0].q).to.be.closeTo(0.6667, 0.0005)\n            expect(Hex.secondCall.args[0].r).to.be.closeTo(0.2440, 0.0005)\n        })\n    })\n\n    it('rounds that hex', function() {\n        pointToHex(point)\n        expect(round).to.have.been.called\n    })\n\n    it('returns the hex', function() {\n        const result = pointToHex(point)\n        expect(result).to.equal('round result')\n    })\n})\n\ndescribe('parallelogram', function() {\n    let parallelogram\n\n    before(function() {\n        parallelogram = statics.parallelogramFactory({ Grid, Hex })\n    })\n\n    it('returns a grid instance with a length of (width ⨉ height) hexes', function() {\n        const gridInstance = sinon.createStubInstance(Grid)\n        const GridSpy = sinon.spy(() => gridInstance)\n        const parallelogram = statics.parallelogramFactory({ Grid: GridSpy, Hex })\n        const result = parallelogram({ width: 2, height: 3 })\n\n        expect(result).to.equal(gridInstance)\n        expect(gridInstance.push.callCount).to.equal(6)\n    })\n\n    describe('when called without start hex or direction', function() {\n        it('returns the hexes in a parallelogram shape, starting at Hex(0)', function() {\n            expect(parallelogram({ width: 2, height: 2 })).to.contain.hexes([\n                { x: 0, y: 0 },\n                { x: 1, y: 0 },\n                { x: 0, y: 1 },\n                { x: 1, y: 1 }\n            ])\n        })\n    })\n\n    describe('when called with start hex', function() {\n        it('returns the hexes in a parallelogram shape, starting at the given start hex', function() {\n            expect(parallelogram({\n                width: 2,\n                height: 2,\n                start: Hex(5, 4)\n            })).to.contain.hexes([\n                { x: 5, y: 4 },\n                { x: 6, y: 4 },\n                { x: 5, y: 5 },\n                { x: 6, y: 5 }\n            ])\n        })\n    })\n\n    describe('when called with direction 1', function() {\n        it('returns the hexes in a parallelogram shape, in a southeastern direction', function() {\n            expect(parallelogram({\n                width: 2,\n                height: 2,\n                direction: 1\n            })).to.contain.hexes([\n                { x: 0, y: 0 },\n                { x: 1, y: 0 },\n                { x: 0, y: 1 },\n                { x: 1, y: 1 }\n            ])\n        })\n    })\n\n    describe('when called with direction 3', function() {\n        it('returns the hexes in a parallelogram shape, in a southwestern direction', function() {\n            expect(parallelogram({\n                width: 2,\n                height: 2,\n                direction: 3\n            })).to.contain.hexes([\n                { x: -1, y: 0 },\n                { x: 0, y: 0 },\n                { x: -2, y: 1 },\n                { x: -1, y: 1 }\n            ])\n        })\n    })\n\n    describe('when called with direction 5', function() {\n        it('returns the hexes in a parallelogram shape, in a northern direction', function() {\n            expect(parallelogram({\n                width: 2,\n                height: 2,\n                direction: 5\n            })).to.contain.hexes([\n                { x: 0, y: -2 },\n                { x: -1, y: -1 },\n                { x: 0, y: -1 },\n                { x: 0, y: 0 }\n            ])\n        })\n    })\n\n    describe('when called with an onCreate callback', function() {\n        it('calls the callback for each created hex passing the hex and the grid', function() {\n            const callback = sinon.spy()\n            const result = parallelogram({\n                width: 2,\n                height: 2,\n                onCreate: callback\n            })\n            expect(callback.callCount).to.eql(4)\n            expect(callback).to.always.have.been.calledWithExactly(\n                sinon.match.has('__isHoneycombHex', true),\n                sinon.match.same(result)\n            )\n        })\n    })\n})\n\ndescribe('triangle', function() {\n    let triangle\n\n    before(function() {\n        triangle = statics.triangleFactory({ Grid, Hex })\n    })\n\n    // https://en.wikipedia.org/wiki/Triangular_number\n    it('returns a grid instance with a length of the triangular number of the size', function() {\n        const gridInstance = sinon.createStubInstance(Grid)\n        const GridSpy = sinon.spy(() => gridInstance)\n        const triangle = statics.triangleFactory({ Grid: GridSpy, Hex })\n        const result = triangle({ size: 4 })\n\n        expect(result).to.equal(gridInstance)\n        expect(gridInstance.push.callCount).to.equal(4 + 3 + 2 + 1)\n    })\n\n    describe('when called without start hex or direction', function() {\n        it('returns the hexes in a triangle shape, starting at Hex(0)', function() {\n            expect(triangle({ size: 2 })).to.contain.hexes([\n                { x: 0, y: 0 },\n                { x: 1, y: 0 },\n                { x: 0, y: 1 }\n            ])\n        })\n    })\n\n    describe('when called with start hex', function() {\n        it('returns the hexes in a triangle shape, starting at the given start hex', function() {\n            expect(triangle({\n                size: 2,\n                start: Hex(3, 6)\n            })).to.contain.hexes([\n                { x: 3, y: 6 },\n                { x: 4, y: 6 },\n                { x: 3, y: 7 }\n            ])\n        })\n    })\n\n    describe('when called with direction 1', function() {\n        it('returns the hexes in a triangle shape, pointing down', function() {\n            expect(triangle({\n                size: 2,\n                direction: 1\n            })).to.contain.hexes([\n                { x: 0, y: 0 },\n                { x: 1, y: 0 },\n                { x: 0, y: 1 }\n            ])\n        })\n    })\n\n    describe('when called with direction 5', function() {\n        it('returns the hexes in a triangle shape, pointing up', function() {\n            expect(triangle({\n                size: 2,\n                direction: 5\n            })).to.contain.hexes([\n                { x: 1, y: 1 },\n                { x: 1, y: 2 },\n                { x: 2, y: 2 }\n            ])\n        })\n    })\n\n    describe('when called with an onCreate callback', function() {\n        it('calls the callback for each created hex passing the hex and the grid', function() {\n            const callback = sinon.spy()\n            const result = triangle({\n                size: 2,\n                onCreate: callback\n            })\n            expect(callback.callCount).to.eql(3)\n            expect(callback).to.always.have.been.calledWithExactly(\n                sinon.match.has('__isHoneycombHex', true),\n                sinon.match.same(result)\n            )\n        })\n    })\n})\n\ndescribe('hexagon', function() {\n    let hexagon\n\n    before(function() {\n        hexagon = statics.hexagonFactory({ Grid, Hex })\n    })\n\n    it('returns a grid instance with a hard to determine amount of hexes 😬', function() {\n        const gridInstance = sinon.createStubInstance(Grid)\n        const GridSpy = sinon.spy(() => gridInstance)\n        const hexagon = statics.hexagonFactory({ Grid: GridSpy, Hex })\n        const result = hexagon({ radius: 3 })\n\n        expect(result).to.equal(gridInstance)\n        expect(gridInstance.push.callCount).to.equal(37)\n    })\n\n    describe('when called without center hex', function() {\n        it('returns the hexes in a hexagon shape, with its center at Hex(0)', function() {\n            expect(hexagon({ radius: 1 })).to.contain.hexes([\n                { x: -1, y: 1 },\n                { x: 0, y: -1 },\n                { x: -1, y: 0 },\n                { x: 0, y: 0 },\n                { x: 1, y: 0 },\n                { x: -1, y: 1 },\n                { x: 0, y: 1 }\n            ])\n        })\n    })\n\n    describe('when called with center hex', function() {\n        it('returns the hexes in a hexagon shape, with its center at the given center hex', function() {\n            expect(hexagon({\n                radius: 1,\n                center: Hex(3, 1)\n            })).to.contain.hexes([\n                { x: 3, y: 0 },\n                { x: 4, y: 0 },\n                { x: 2, y: 1 },\n                { x: 3, y: 1 },\n                { x: 4, y: 1 },\n                { x: 3, y: 2 },\n                { x: 4, y: 2 }\n            ])\n        })\n    })\n\n    describe('when called with an onCreate callback', function() {\n        it('calls the callback for each created hex passing the hex and the grid', function() {\n            const callback = sinon.spy()\n            const result = hexagon({\n                radius: 1,\n                onCreate: callback\n            })\n            expect(callback.callCount).to.eql(7)\n            expect(callback).to.always.have.been.calledWithExactly(\n                sinon.match.has('__isHoneycombHex', true),\n                sinon.match.same(result)\n            )\n        })\n    })\n})\n\ndescribe('rectangle', function() {\n    let compassToNumberDirectionSpy, signedModuloSpy, Hex, rectangle\n\n    before(function() {\n        compassToNumberDirectionSpy = sinon.spy(compassToNumberDirection)\n        signedModuloSpy = sinon.spy(signedModulo)\n        Hex = extendHex()\n        rectangle = statics.rectangleFactory({\n            Grid,\n            Hex,\n            compassToNumberDirection: compassToNumberDirectionSpy,\n            signedModulo: signedModuloSpy\n        })\n    })\n\n    it('returns a grid instance with a length of (width ⨉ height) hexes', function() {\n        const gridInstance = sinon.createStubInstance(Grid)\n        const GridSpy = sinon.spy(() => gridInstance)\n        const rectangle = statics.rectangleFactory({ Grid: GridSpy, Hex })\n        const result = rectangle({ width: 4, height: 5 })\n\n        expect(result).to.equal(gridInstance)\n        expect(gridInstance.push.callCount).to.equal(20)\n    })\n\n    describe('when called with a compass direction', () => {\n        it('calls compassToNumberDirection', () => {\n            rectangle({ direction: 'E' })\n            expect(compassToNumberDirectionSpy).to.have.been.calledWith('E', 'pointy')\n        })\n    })\n\n    describe('when called with directions outside 0..5', () => {\n        it(`passes them to signedModulo`, () => {\n            rectangle({ direction: -1 })\n            expect(signedModuloSpy).to.have.been.calledWith(-1, 6)\n\n            signedModuloSpy.reset()\n\n            rectangle({ direction: 3 })\n            expect(signedModuloSpy).not.to.have.been.called\n        })\n    })\n\n    describe('when hexes have a pointy orientation', function() {\n        before(function() {\n            Hex = extendHex({ orientation: 'pointy' })\n            rectangle = statics.rectangleFactory({ Grid, Hex })\n        })\n\n        describe('when called without start hex or direction', function() {\n            it('returns the hexes in a rectangle shape in direction 0, starting at Hex(0)', function() {\n                expect(rectangle({ width: 2, height: 3 })).to.contain.hexes([\n                    { x: 0, y: 0 },\n                    { x: 1, y: 0 },\n                    { x: 0, y: 1 },\n                    { x: 1, y: 1 },\n                    { x: 0, y: 2 },\n                    { x: 1, y: 2 }\n                ])\n            })\n        })\n\n        describe('when called with start hex', function() {\n            it('returns the hexes in a rectangle shape, starting at the given start hex', function() {\n                expect(rectangle({\n                    width: 2,\n                    height: 3,\n                    start: Hex(-4, -2)\n                })).to.contain.hexes([\n                    { x: -4, y: -2 },\n                    { x: -3, y: -2 },\n                    { x: -4, y: -1 },\n                    { x: -3, y: -1 },\n                    { x: -4, y: 0 },\n                    { x: -3, y: 0 }\n                ])\n            })\n        })\n\n        describe('when called with direction 0', function() {\n            it('returns the hexes in a rectangle shape, in an eastern direction', function() {\n                expect(rectangle({\n                    width: 2,\n                    height: 2,\n                    direction: 0\n                })).to.contain.hexes([\n                    { x: 0, y: 0 },\n                    { x: 1, y: 0 },\n                    { x: 0, y: 1 },\n                    { x: 1, y: 1 }\n                ])\n            })\n        })\n\n        describe('when called with direction 1', function() {\n            it('returns the hexes in a rectangle shape, in a southeastern direction', function() {\n                expect(rectangle({\n                    width: 2,\n                    height: 2,\n                    direction: 1\n                })).to.contain.hexes([\n                    { x: 0, y: 0 },\n                    { x: 0, y: 1 },\n                    { x: 1, y: 0 },\n                    { x: 1, y: 1 }\n                ])\n            })\n        })\n\n        describe('when called with direction 2', function() {\n            it('returns the hexes in a rectangle shape, in a southwestern direction', function() {\n                expect(rectangle({\n                    width: 2,\n                    height: 2,\n                    direction: 2\n                })).to.contain.hexes([\n                    { x: 0, y: 0 },\n                    { x: -1, y: 1 },\n                    { x: -1, y: 0 },\n                    { x: -2, y: 1 }\n                ])\n            })\n        })\n\n        describe('when called with direction 3', function() {\n            it('returns the hexes in a rectangle shape, in a western direction', function() {\n                expect(rectangle({\n                    width: 2,\n                    height: 2,\n                    direction: 3\n                })).to.contain.hexes([\n                    { x: 0, y: 0 },\n                    { x: -1, y: 0 },\n                    { x: -1, y: 1 },\n                    { x: -2, y: 1 }\n                ])\n            })\n        })\n\n        describe('when called with direction 4', function() {\n            it('returns the hexes in a rectangle shape, in a northwestern direction', function() {\n                expect(rectangle({\n                    width: 2,\n                    height: 2,\n                    direction: 4\n                })).to.contain.hexes([\n                    { x: 0, y: -2 },\n                    { x: -1, y: -1 },\n                    { x: 0, y: -1 },\n                    { x: 0, y: 0 }\n                ])\n            })\n        })\n\n        describe('when called with direction 5', function() {\n            it('returns the hexes in a rectangle shape, in a northeastern direction', function() {\n                expect(rectangle({\n                    width: 2,\n                    height: 2,\n                    direction: 5\n                })).to.contain.hexes([\n                    { x: 0, y: -2 },\n                    { x: -1, y: -1 },\n                    { x: 0, y: -1 },\n                    { x: 0, y: 0 }\n                ])\n            })\n        })\n    })\n\n    describe('when hexes have a flat orientation', function() {\n        before(function() {\n            Hex = extendHex({ orientation: 'flat' })\n            rectangle = statics.rectangleFactory({ Grid, Hex })\n        })\n\n        describe('when called without start hex or direction', function() {\n            it('returns the hexes in a rectangle shape in direction 1, starting at Hex(0)', function() {\n                expect(rectangle({ width: 2, height: 3 })).to.contain.hexes([\n                    { x: 0, y: 0 },\n                    { x: 1, y: 0 },\n                    { x: 0, y: 1 },\n                    { x: 1, y: 1 },\n                    { x: 0, y: 2 },\n                    { x: 1, y: 2 }\n                ])\n            })\n        })\n\n        describe('when called with start hex', function() {\n            it('returns the hexes in a rectangle shape, starting at the given start hex', function() {\n                expect(rectangle({\n                    width: 2,\n                    height: 3,\n                    start: Hex(-4, -2)\n                })).to.contain.hexes([\n                    { x: -4, y: -2 },\n                    { x: -3, y: -2 },\n                    { x: -4, y: -1 },\n                    { x: -3, y: -1 },\n                    { x: -4, y: 0 },\n                    { x: -3, y: 0 }\n                ])\n            })\n        })\n\n        describe('when called with direction 0', function() {\n            it('returns the hexes in a rectangle shape, in a southeastern direction', function() {\n                expect(rectangle({\n                    width: 2,\n                    height: 2,\n                    direction: 0\n                })).to.contain.hexes([\n                    { x: 0, y: 0 },\n                    { x: 1, y: 0 },\n                    { x: 0, y: 1 },\n                    { x: 1, y: 1 }\n                ])\n            })\n        })\n\n        describe('when called with direction 1', function() {\n            it('returns the hexes in a rectangle shape, in a southern direction', function() {\n                expect(rectangle({\n                    width: 2,\n                    height: 2,\n                    direction: 1\n                })).to.contain.hexes([\n                    { x: 0, y: 0 },\n                    { x: 0, y: 1 },\n                    { x: 1, y: 0 },\n                    { x: 1, y: 1 }\n                ])\n            })\n        })\n\n        describe('when called with direction 2', function() {\n            it('returns the hexes in a rectangle shape, in a southwestern direction', function() {\n                expect(rectangle({\n                    width: 2,\n                    height: 2,\n                    direction: 2\n                })).to.contain.hexes([\n                    { x: -1, y: -1 },\n                    { x: -2, y: 0 },\n                    { x: 0, y: 0 },\n                    { x: -1, y: 0 }\n                ])\n            })\n        })\n\n        describe('when called with direction 3', function() {\n            it('returns the hexes in a rectangle shape, in a northwestern direction', function() {\n                expect(rectangle({\n                    width: 2,\n                    height: 2,\n                    direction: 3\n                })).to.contain.hexes([\n                    { x: -1, y: -1 },\n                    { x: -2, y: 0 },\n                    { x: -1, y: 0 },\n                    { x: 0, y: 0 }\n                ])\n            })\n        })\n\n        describe('when called with direction 4', function() {\n            it('returns the hexes in a rectangle shape, in a northern direction', function() {\n                expect(rectangle({\n                    width: 2,\n                    height: 2,\n                    direction: 4\n                })).to.contain.hexes([\n                    { x: 0, y: 0 },\n                    { x: 0, y: -1 },\n                    { x: 1, y: -1 },\n                    { x: 1, y: -2 }\n                ])\n            })\n        })\n\n        describe('when called with direction 5', function() {\n            it('returns the hexes in a rectangle shape, in a northeastern direction', function() {\n                expect(rectangle({\n                    width: 2,\n                    height: 2,\n                    direction: 5\n                })).to.contain.hexes([\n                    { x: 0, y: 0 },\n                    { x: 1, y: -1 },\n                    { x: 0, y: -1 },\n                    { x: 1, y: -2 }\n                ])\n            })\n        })\n    })\n\n    describe('when called with an onCreate callback', function() {\n        it('calls the callback for each created hex passing the hex and the grid', function() {\n            const callback = sinon.spy()\n            const result = rectangle({\n                width: 2,\n                height: 2,\n                onCreate: callback\n            })\n            expect(callback.callCount).to.eql(4)\n            expect(callback).to.always.have.been.calledWithExactly(\n                sinon.match.has('__isHoneycombHex', true),\n                sinon.match.same(result)\n            )\n        })\n    })\n})\n",
    "static": true,
    "longname": "/Users/abbe/Projects/honeycomb/src/grid/statics.spec.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 86,
    "kind": "variable",
    "name": "extendHex",
    "memberof": "src/grid/statics.spec.js",
    "static": true,
    "longname": "src/grid/statics.spec.js~extendHex",
    "access": "public",
    "export": false,
    "importPath": "honeycomb-grid/src/grid/statics.spec.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 11,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 87,
    "kind": "variable",
    "name": "Hex",
    "memberof": "src/grid/statics.spec.js",
    "static": true,
    "longname": "src/grid/statics.spec.js~Hex",
    "access": "public",
    "export": false,
    "importPath": "honeycomb-grid/src/grid/statics.spec.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 12,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 88,
    "kind": "file",
    "name": "src/hex/constants.js",
    "content": "/**\n * The different orientations hexes can have.\n *\n * @readonly\n * @enum {string}\n *\n * @property {string} pointy    ⬢\n * @property {string} flat      ⬣\n */\nexport const ORIENTATION = {\n    pointy: 'pointy',\n    flat: 'flat'\n}\n\n/**\n * How rows/columns of hexes are placed relative to each other.\n *\n * An even offset:\n * * places **even rows** of **pointy hexes** half a hex right of the odd rows;\n * * places **even columns** of **flat hexes** half a hex down of the odd rows;\n *\n * An odd offset:\n * * places **odd rows** of **pointy hexes** half a hex right of the even rows;\n * * places **odd columns** of **flat hexes** half a hex down of the even rows;\n *\n * @name OFFSET\n *\n * @see {@link https://www.redblobgames.com/grids/hexagons/#coordinates-offset|redblobgames.com}\n *\n * @readonly\n * @enum {number}\n *\n * @property {number} even  +1\n * @property {number} odd   -1\n */\nexport const OFFSET = {\n    even: 1,\n    odd: -1\n}\n\nexport const DIRECTION_COORDINATES = [\n    { q: 1, r: 0 },\n    { q: 0, r: 1 },\n    { q: -1, r: 1 },\n    { q: -1, r: 0 },\n    { q: 0, r: -1 },\n    { q: 1, r: -1 }\n]\n\nexport const DIAGONAL_DIRECTION_COORDINATES = [\n    { q: 2, r: -1 },\n    { q: 1, r: 1 },\n    { q: -1, r: 2 },\n    { q: -2, r: 1 },\n    { q: -1, r: -1 },\n    { q: 1, r: -2 }\n]\n\nexport const EPSILON = { x: 1e-6, y: 1e-6 }\n",
    "static": true,
    "longname": "/Users/abbe/Projects/honeycomb/src/hex/constants.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 89,
    "kind": "variable",
    "name": "ORIENTATION",
    "memberof": "src/hex/constants.js",
    "static": true,
    "longname": "src/hex/constants.js~ORIENTATION",
    "access": "public",
    "export": true,
    "importPath": "honeycomb-grid/src/hex/constants.js",
    "importStyle": "{ORIENTATION}",
    "description": "The different orientations hexes can have.",
    "lineNumber": 10,
    "unknown": [
      {
        "tagName": "@readonly",
        "tagValue": ""
      },
      {
        "tagName": "@enum",
        "tagValue": "{string}"
      }
    ],
    "properties": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "pointy",
        "description": "⬢"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "flat",
        "description": "⬣"
      }
    ],
    "type": {
      "types": [
        "{\"pointy\": string, \"flat\": string}"
      ]
    }
  },
  {
    "__docId__": 90,
    "kind": "variable",
    "name": "OFFSET",
    "memberof": "src/hex/constants.js",
    "static": true,
    "longname": "src/hex/constants.js~OFFSET",
    "access": "public",
    "export": true,
    "importPath": "honeycomb-grid/src/hex/constants.js",
    "importStyle": "{OFFSET}",
    "description": null,
    "lineNumber": 36,
    "undocument": true,
    "type": {
      "types": [
        "{\"even\": number, \"odd\": *}"
      ]
    }
  },
  {
    "__docId__": 91,
    "kind": "variable",
    "name": "DIRECTION_COORDINATES",
    "memberof": "src/hex/constants.js",
    "static": true,
    "longname": "src/hex/constants.js~DIRECTION_COORDINATES",
    "access": "public",
    "export": true,
    "importPath": "honeycomb-grid/src/hex/constants.js",
    "importStyle": "{DIRECTION_COORDINATES}",
    "description": null,
    "lineNumber": 41,
    "undocument": true,
    "type": {
      "types": [
        "undefined[]"
      ]
    }
  },
  {
    "__docId__": 92,
    "kind": "variable",
    "name": "DIAGONAL_DIRECTION_COORDINATES",
    "memberof": "src/hex/constants.js",
    "static": true,
    "longname": "src/hex/constants.js~DIAGONAL_DIRECTION_COORDINATES",
    "access": "public",
    "export": true,
    "importPath": "honeycomb-grid/src/hex/constants.js",
    "importStyle": "{DIAGONAL_DIRECTION_COORDINATES}",
    "description": null,
    "lineNumber": 50,
    "undocument": true,
    "type": {
      "types": [
        "undefined[]"
      ]
    }
  },
  {
    "__docId__": 93,
    "kind": "variable",
    "name": "EPSILON",
    "memberof": "src/hex/constants.js",
    "static": true,
    "longname": "src/hex/constants.js~EPSILON",
    "access": "public",
    "export": true,
    "importPath": "honeycomb-grid/src/hex/constants.js",
    "importStyle": "{EPSILON}",
    "description": null,
    "lineNumber": 59,
    "undocument": true,
    "type": {
      "types": [
        "{\"x\": number, \"y\": number}"
      ]
    }
  },
  {
    "__docId__": 94,
    "kind": "file",
    "name": "src/hex/index.js",
    "content": "import { isObject, isNumber, isArray } from 'axis.js'\n\nimport { ensureXY } from '../utils'\nimport { ORIENTATION, OFFSET } from './constants'\nimport PointFactory from '../point'\nimport * as statics from './statics'\nimport * as methods from './prototype'\n\nconst Point = PointFactory({ ensureXY })\n\nexport const staticMethods = {\n    thirdCoordinate: statics.thirdCoordinate\n}\n\nexport default function extendHexFactory({ ensureXY }) {\n    /**\n     * @function extendHex\n     *\n     * @memberof Honeycomb\n     * @static\n     *\n     * @description\n     * This function can be used to create custom hexes by extending the default Hex prototype.\n     *\n     * All properties of the object passed to `extendHex()` will be added to the prototype of the resulting {@link Hex} factory.\n     * To add properties to individual hexes (instances), pass them to the {@link Hex} factory.\n     *\n     * @todo validate orientation, size, origin\n     * @todo warn when properties are overriden\n     *\n     * @param {Object} [prototype={}]   An object that's used as the prototype for all hexes in a grid.\n     *                                  **Warning:** properties in this object will overwrite properties with the same name in the default prototype.\n     *\n     * @returns {Hex}                   A function to produce hexes that are all linked to the same prototype.\n     *\n     * @example\n     * const Hex = Honeycomb.extendHex({\n     *     size: 50,\n     *     orientation: 'flat',\n     *     customProperty: `I'm custom 😃`,\n     *     customMethod() {\n     *         return `${this.customProperty} and called from a custom method 😎`\n     *     }\n     * })\n     * const hex = Hex(5, -1)\n     *\n     * hex.coordinates()    // { x: 5, y: -1 }\n     * hex.size             // 50\n     * hex.customProperty   // I'm custom 😃\n     * hex.customMethod()   // I'm custom 😃 and called from a custom method 😎\n     *\n     * // every hex created with Hex() shares these properties:\n     * const hex2 = Hex(3, 0)\n     * hex2.size            // 50\n     * hex2.customProperty  // I'm custom 😃\n     *\n     * // to set properties on individual hexes, pass them to Hex():\n     * const hex3 = Hex(-2, -1, { instanceProperty: `I'm a unique snowflake 😌` })\n     * hex3.instanceProperty    // I'm a unique snowflake 😌\n     */\n    return function extendHex(prototype = {}) {\n        const defaultPrototype = {\n            /**\n             * Used internally for type checking\n             *\n             * @memberof Hex#\n             * @private\n             */\n            __isHoneycombHex: true,\n            /**\n             * Either pointy or flat. Defaults to `pointy`.\n             *\n             * @memberof Hex#\n             * @type {string}\n             * @default ORIENTATION.pointy\n             */\n            orientation: ORIENTATION.pointy,\n            /**\n             * Distance from a hex's top left corner (as if it were a rectange). Defaults to `Point(0)`.\n             * Can be anything the {@link Honeycomb.Point} factory accepts.\n             * When a {@link Hex#toPoint|hex is converted to a point}, it is converted to this origin.\n             *\n             * @memberof Hex#\n             * @type {point}\n             * @default 0\n             */\n            origin: 0,\n            /**\n             * A hex's radius or the length of any of its sides. Defaults to `1`.\n             *\n             * @memberof Hex#\n             * @type {number}\n             * @default 1\n             */\n            size: 1,\n            /**\n             * Used to calculate the coordinates of rows for pointy hexes and columns for flat hexes.\n             * Defaults to `-1` (odd offset).\n             * See {@link OFFSET} for details.\n             * See {@link https://www.redblobgames.com/grids/hexagons/#coordinates-offset|redblobgames.com} why this is needed.\n             *\n             * @memberof Hex#\n             * @type {number}\n             * @default -1\n             * @see OFFSET\n             */\n            offset: OFFSET.odd,\n            /**\n             * Getter for `q` cube coordinate. Calls {@link Hex#cartesianToCube} internally.\n             *\n             * @memberof Hex#\n             * @type {number}\n             */\n            get q() { return _cubeProp(this, 'q') },\n            /**\n             * Getter for `r` cube coordinate. Calls {@link Hex#cartesianToCube} internally.\n             *\n             * @memberof Hex#\n             * @type {number}\n             */\n            get r() { return _cubeProp(this, 'r') },\n            /**\n             * Getter for `s` cube coordinate. Calls {@link Hex#cartesianToCube} internally.\n             *\n             * @memberof Hex#\n             * @type {number}\n             */\n            get s() { return _cubeProp(this, 's') },\n\n            // methods:\n            add: methods.addFactory({ Hex, Point }),\n            /**\n             * Alias for {@link Hex#coordinates}.\n             * @memberof Hex#\n             * @instance\n             */\n            cartesian: methods.coordinates,\n            cartesianToCube: methods.cartesianToCube,\n            center: methods.centerFactory({ Point }),\n            coordinates: methods.coordinates,\n            corners: methods.cornersFactory({ Point }),\n            cube: methods.cube,\n            cubeToCartesian: methods.cubeToCartesian,\n            distance: methods.distance,\n            equals: methods.equalsFactory({ Point }),\n            height: methods.height,\n            isFlat: methods.isFlat,\n            isPointy: methods.isPointy,\n            lerp: methods.lerpFactory({ Hex }),\n            nudge: methods.nudge,\n            oppositeCornerDistance: methods.oppositeCornerDistance,\n            oppositeSideDistance: methods.oppositeSideDistance,\n            round: methods.roundFactory({ Hex }),\n            set: methods.setFactory({ Hex }),\n            subtract: methods.subtractFactory({ Hex, Point }),\n            /**\n             * Alias for {@link Hex#cubeToCartesian}.\n             * @memberof Hex#\n             * @instance\n             */\n            toCartesian: methods.cubeToCartesian,\n            /**\n             * Alias for {@link Hex#cartesianToCube}.\n             * @memberof Hex#\n             * @instance\n             */\n            toCube: methods.cartesianToCube,\n            toPoint: methods.toPointFactory({ Point }),\n            toString: methods.toString,\n            width: methods.width\n        }\n        const finalPrototype = Object.assign(defaultPrototype, prototype)\n\n        // ensure origin is a point\n        finalPrototype.origin = Point(finalPrototype.origin)\n\n        Object.assign(Hex, staticMethods)\n\n        /**\n         * @function Hex\n         *\n         * @description\n         * Factory function to create hexes. Use {@link Honeycomb.extendHex} to create a Hex factory.\n         *\n         * @see {@link redblobgames.com|https://www.redblobgames.com/grids/hexagons/#coordinates}\n         *\n         * @param {(number|Object|number[])} [xOrProps=]    The x coordinate,\n         *                                                  **or** an object containing *any* of the cartesian (`x` and `y`) coordinates and optional custom properties,\n         *                                                  **or** an object containing *all* of the cube (`q`, `r`, and `s`) coordinates and optional custom properties,\n         *                                                  **or** an array containing *any* of the cartesian (x and y) coordinates.\n         * @param {number} [xOrProps.x=]                    The x coordinate.\n         * @param {number} [xOrProps.y=]                    The y coordinate.\n         * @param {number} [y=]                             The y coordinate.\n         * @param {object} [customProps={}]                 Any custom properties. The coordinates are merged into this object, ignoring any coordinates present in `customProps`.\n         *\n         * @returns {hex}                                   A hex. It *always* contains *only* the cartesian (x and y) coordinates and any custom properties.\n         *\n         * @example\n         * const Hex = Honeycomb.extendHex()\n         *\n         * // passing numbers:\n         * Hex()                        // { x: 0, y: 0 }\n         * Hex(1)                       // { x: 1, y: 1 }\n         * Hex(1, 2)                    // { x: 1, y: 2 }\n         *\n         * // passing an object with cartesian coordinates:\n         * Hex({})                      // { x: 0, y: 0 }\n         * Hex({ x: 1 })                // { x: 1, y: 1 }\n         * Hex({ y: 2 })                // { x: 2, y: 2 }\n         * Hex({ x: 1, y: 2 })          // { x: 1, y: 2 }\n         *\n         * // passing an object with cube coordinates:\n         * Hex({ q: 1, r: 2, s: -3 })   // { x: 2, y: 2 }\n         * Hex({ q: 1 })                // throws an error because of missing cube coordinates\n         *\n         * // passing an array:\n         * Hex([])                      // { x: 0, y: 0 }\n         * Hex([1])                     // { x: 1, y: 1 }\n         * Hex([1, 2])                  // { x: 1, y: 2 }\n         *\n         * // custom properties:\n         * Hex(1, 2, { a: 3 })          // { a: 3, x: 1, y: 2 }\n         * Hex({ x: 1, y: 2, a: 3 })    // { a: 3, x: 1, y: 2 }\n         *\n         * // cloning a hex:\n         * const someHex = Hex(4, -2)   // { x: 4, y: -2 }\n         * const clone = Hex(someHex)   // { x: 4, y: -2 }\n         * someHex === clone            // false\n         */\n        function Hex(xOrProps, y, customProps = {}) {\n            let x\n\n            if (isObject(xOrProps)) {\n                let { q, r, s, ...rest } = xOrProps\n\n                if (isNumber(q) || isNumber(r) || isNumber(s)) {\n                    if (q + r + s !== 0) {\n                        throw new Error(`Cube coordinates must have a sum of 0. q: ${q}, r: ${r}, s: ${s}, sum: ${q + r + s}.`)\n                    }\n\n                    ({ x, y } = finalPrototype.cubeToCartesian({ q, r, s }))\n                } else {\n                    ({ x, y } = xOrProps)\n                }\n\n                customProps = rest\n            } else if (isArray(xOrProps)) {\n                [x, y] = xOrProps\n                // ignore all arguments except xOrProps\n                customProps = {}\n            } else {\n                x = xOrProps\n            }\n\n            /**\n             * An object with x and y properties and several methods in its prototype chain, created by a {@link Hex} factory.\n             *\n             * @typedef {Object} hex\n             * @property {number} x Cartesian x coordinate.\n             * @property {number} y Cartesian y coordinate.\n             */\n            return Object.assign(\n                // the prototype has to be attached here, else Grid's shape methods break 🙁\n                Object.create(finalPrototype),\n                // also merge any custom properties already present\n                this,\n                Object.assign(customProps, ensureXY(x, y))\n            )\n        }\n\n        return Hex\n    }\n}\n\nfunction _cubeProp(context, prop) {\n    return context.cartesianToCube({ x: context.x, y: context.y })[prop]\n}\n",
    "static": true,
    "longname": "/Users/abbe/Projects/honeycomb/src/hex/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 95,
    "kind": "variable",
    "name": "Point",
    "memberof": "src/hex/index.js",
    "static": true,
    "longname": "src/hex/index.js~Point",
    "access": "public",
    "export": false,
    "importPath": "honeycomb-grid/src/hex/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 96,
    "kind": "variable",
    "name": "staticMethods",
    "memberof": "src/hex/index.js",
    "static": true,
    "longname": "src/hex/index.js~staticMethods",
    "access": "public",
    "export": true,
    "importPath": "honeycomb-grid/src/hex/index.js",
    "importStyle": "{staticMethods}",
    "description": null,
    "lineNumber": 11,
    "undocument": true,
    "type": {
      "types": [
        "{\"thirdCoordinate\": *}"
      ]
    }
  },
  {
    "__docId__": 97,
    "kind": "function",
    "name": "extendHexFactory",
    "memberof": "src/hex/index.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/hex/index.js~extendHexFactory",
    "access": "public",
    "export": true,
    "importPath": "honeycomb-grid/src/hex/index.js",
    "importStyle": "extendHexFactory",
    "description": null,
    "lineNumber": 15,
    "undocument": true,
    "params": [
      {
        "name": "objectPattern",
        "types": [
          "{\"ensureXY\": *}"
        ],
        "defaultRaw": {
          "ensureXY": null
        },
        "defaultValue": "{\"ensureXY\":null}"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 98,
    "kind": "typedef",
    "name": "hex",
    "memberof": "src/hex/index.js",
    "static": true,
    "longname": "src/hex/index.js~hex",
    "access": "public",
    "description": "An object with x and y properties and several methods in its prototype chain, created by a {@link Hex} factory.",
    "lineNumber": 262,
    "properties": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "x",
        "description": "Cartesian x coordinate."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "y",
        "description": "Cartesian y coordinate."
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "hex"
    }
  },
  {
    "__docId__": 99,
    "kind": "function",
    "name": "_cubeProp",
    "memberof": "src/hex/index.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/hex/index.js~_cubeProp",
    "access": "private",
    "export": false,
    "importPath": "honeycomb-grid/src/hex/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 275,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "context",
        "types": [
          "*"
        ]
      },
      {
        "name": "prop",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 100,
    "kind": "file",
    "name": "src/hex/index.spec.js",
    "content": "/* eslint-env mocha */\n\nimport { expect } from 'chai'\nimport sinon from 'sinon'\n\nimport { ensureXY } from '../utils'\nimport extendHexFactory, { staticMethods } from '../../src/hex'\nimport { ORIENTATION, OFFSET } from './constants'\n\nconst ensureXYSpy = sinon.spy(ensureXY)\nconst extendHex = extendHexFactory({ ensureXY: ensureXYSpy })\n\ndescribe('extendHex', function() {\n    let Hex\n\n    beforeEach(() => {\n        Hex = extendHex()\n    })\n\n    it('returns a function', function() {\n        expect(Hex).to.be.a('function')\n    })\n\n    it('returns a function that has the Hex static methods', function() {\n        expect(Object.entries(Hex)).to.eql(Object.entries(staticMethods))\n    })\n\n    it('returns a function with the default prototype', function() {\n        const prototype = Object.getPrototypeOf(Hex())\n        const prototypeProps = Object.keys(prototype)\n\n        expect(prototypeProps).to.eql([\n            '__isHoneycombHex',\n\n            'orientation',\n            'origin',\n            'size',\n            'offset',\n            'q',\n            'r',\n            's',\n\n            'add',\n            'cartesian',\n            'cartesianToCube',\n            'center',\n            'coordinates',\n            'corners',\n            'cube',\n            'cubeToCartesian',\n            'distance',\n            'equals',\n            'height',\n            'isFlat',\n            'isPointy',\n            'lerp',\n            'nudge',\n            'oppositeCornerDistance',\n            'oppositeSideDistance',\n            'round',\n            'set',\n            'subtract',\n            'toCartesian',\n            'toCube',\n            'toPoint',\n            'toString',\n            'width'\n        ])\n        expect(prototype).to.have.property('__isHoneycombHex', true)\n        expect(prototype).to.have.property('orientation', ORIENTATION.pointy)\n        expect(prototype).to.have.property('origin').that.contains({ x: 0, y: 0 })\n        expect(prototype).to.have.property('size', 1)\n        expect(prototype).to.have.property('offset', OFFSET.odd)\n    })\n\n    it('has getters for the q, r and s cube coordinates', () => {\n        const cartesianToCube = sinon.stub().returns({ q: 'q', r: 'r', s: 's' })\n        const hex = extendHex({ cartesianToCube })()\n\n        expect(hex.q).to.equal('q')\n        expect(hex.r).to.equal('r')\n        expect(hex.s).to.equal('s')\n        expect(() => hex.q = 1).to.throw\n        expect(() => hex.r = 1).to.throw\n        expect(() => hex.s = 1).to.throw\n    })\n\n    describe('when passed an object', function() {\n        it(`returns a Hex factory with the object's properties merged into the default prototype`, function() {\n            const prototype = {\n                size: 100,\n                custom: 'property'\n            }\n            const Hex = extendHex(prototype)\n            const finalPrototype = Object.getPrototypeOf(Hex())\n\n            expect(finalPrototype).to.have.own.property('size', 100)\n            expect(finalPrototype).to.have.own.property('custom')\n        })\n\n        it(`creates a different Hex factory each time it's called`, function() {\n            const Hex1 = extendHex({ size: 10 })\n            const Hex2 = extendHex({ size: 20 })\n\n            expect(Hex1().size).not.to.equal(Hex2().size)\n        })\n    })\n})\n\ndescribe('Hex creation', function() {\n    let Hex\n\n    before(function() {\n        Hex = extendHex()\n    })\n\n    it('calls ensureXY', () => {\n        Hex(1, 2)\n        expect(ensureXYSpy).to.have.been.calledWith(1, 2)\n    })\n\n    describe('with 2 numbers', function() {\n        it('sets them as x and y coordinates', function() {\n            expect(Hex(3, -5)).to.contain({ x: 3, y: -5 })\n        })\n    })\n\n    describe('with 1 number', function() {\n        it('sets the missing coordinate to the same value as the passed coordinate', function() {\n            expect(Hex(3, null)).to.contain({ x: 3, y: 3 })\n            expect(Hex(null, 2)).to.contain({ x: 2, y: 2 })\n        })\n    })\n\n    describe('with a 3rd argument that is an object', function() {\n        it('merges the object in the hex', function() {\n            expect(Hex(3, 2, { custom: 'property' })).to.contain({ x: 3, y: 2, custom: 'property' })\n        })\n\n        it('ignores any coordinates in the object', function() {\n            expect(Hex(3, 2, { x: 0, y: 0 })).to.contain({ x: 3, y: 2 })\n        })\n    })\n\n    describe('with an object containing x and y properties', function() {\n        it('sets the coordinates', function() {\n            expect(Hex({ x: 3, y: 2 })).to.contain({ x: 3, y: 2 })\n        })\n    })\n\n    describe('with an object containing either an x or y coordinate', function() {\n        it('sets the missing coordinate to the same value as the passed coordinate', function() {\n            expect(Hex({ x: 3 })).to.contain({ x: 3, y: 3 })\n            expect(Hex({ y: 2 })).to.contain({ x: 2, y: 2 })\n        })\n    })\n\n    describe('with an object containing all cube coordinates (q, r and s)', () => {\n        it('converts them to rectangular (x and y) coordinates', () => {\n            const cubeToCartesian = sinon.stub().returns({ x: 4, y: 5 })\n            const Hex = extendHex({ cubeToCartesian })\n            const result = Hex({ q: 1, r: 2, s: -3 })\n\n            expect(cubeToCartesian).to.have.been.calledWith({ q: 1, r: 2, s: -3 })\n            expect(result).to.contain({ x: 4, y: 5 })\n        })\n    })\n\n    describe(`with an object containing all cube coordinates (q, r and s) that don't sum to 0`, () => {\n        it('throws an error', () => {\n            expect(() => Hex({ q: 1, r: 2, s: 3 })).to.throw(\n                `Cube coordinates must have a sum of 0. q: 1, r: 2, s: 3, sum: 6.`\n            )\n        })\n    })\n\n    describe('with an object containing some cube coordinates (q, r and s)', () => {\n        it('throws an error', () => {\n            expect(() => Hex({ q: 1 })).to.throw(\n                `Cube coordinates must have a sum of 0. q: 1, r: undefined, s: undefined, sum: NaN.`\n            )\n        })\n    })\n\n    describe('with an object containing no coordinates', function() {\n        it('sets both coordinates to 0', function() {\n            expect(Hex({})).to.contain({ x: 0, y: 0 })\n        })\n    })\n\n    describe('with an object containing custom properties', function() {\n        it('sets the custom properties', function() {\n            expect(Hex({ custom: 'property' })).to.contain({ custom: 'property' })\n        })\n    })\n\n    describe('with an object and more arguments', function() {\n        it('ignores all but the object', function() {\n            const result = Hex({ x: 1, y: -3, custom: 'a' }, 8, { x: 0, y: 0, custom: 'b' })\n            expect(result).to.contain({ x: 1, y: -3, custom: 'a' })\n            expect(result).not.to.contain({ custom: 'b' })\n        })\n    })\n\n    describe('without parameters', function() {\n        it('sets both coordinates to 0', function() {\n            expect(Hex()).to.contain({ x: 0, y: 0 })\n        })\n    })\n\n    describe('with an array containing 2 numbers', function() {\n        it('sets them as x and y coordinates', function() {\n            expect(Hex([3, 0])).to.contain({ x: 3, y: 0 })\n        })\n    })\n\n    describe('with an array containing 1 number', function() {\n        it('sets the missing coordinate to the same value as the passed coordinate', function() {\n            expect(Hex([3])).to.contain({ x: 3, y: 3 })\n            expect(Hex([null, 2])).to.contain({ x: 2, y: 2 })\n        })\n    })\n\n    describe('with an array containing more than 2 numbers', function() {\n        it('ignores all but the first 2 array elements', function() {\n            const result = Hex([3, 2, { custom: 'a', x: 0 }, 8])\n            expect(result).to.contain({ x: 3, y: 2 })\n            expect(result).not.to.contain({ custom: 'a' })\n        })\n    })\n\n    describe('with an empty array', function() {\n        it('sets both coordinates to 0', function() {\n            expect(Hex([])).to.contain({ x: 0, y: 0 })\n        })\n    })\n\n    describe('with an array and more arguments', function() {\n        it('ignores all but the array', function() {\n            const result = Hex([1, -3], 8, { x: 0, y: 0, custom: 'a' })\n            expect(result).to.contain({ x: 1, y: -3 })\n            expect(result).not.to.contain({ custom: 'a' })\n        })\n    })\n\n    describe('with a falsy value', function() {\n        it('sets both coordinates to 0', function() {\n            const bothZeroCoordinates = { x: 0, y: 0 }\n            expect(Hex(undefined)).to.contain(bothZeroCoordinates)\n            expect(Hex(null)).to.contain(bothZeroCoordinates)\n            expect(Hex('')).to.contain(bothZeroCoordinates)\n            expect(Hex(false)).to.contain(bothZeroCoordinates)\n        })\n    })\n\n    describe('with a hex', function() {\n        it('clones the hex', function() {\n            const someHex = Hex()\n            const clonedHex = Hex(someHex)\n            expect(clonedHex).not.to.equal(someHex)\n        })\n    })\n})\n",
    "static": true,
    "longname": "/Users/abbe/Projects/honeycomb/src/hex/index.spec.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 101,
    "kind": "variable",
    "name": "ensureXYSpy",
    "memberof": "src/hex/index.spec.js",
    "static": true,
    "longname": "src/hex/index.spec.js~ensureXYSpy",
    "access": "public",
    "export": false,
    "importPath": "honeycomb-grid/src/hex/index.spec.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 102,
    "kind": "variable",
    "name": "extendHex",
    "memberof": "src/hex/index.spec.js",
    "static": true,
    "longname": "src/hex/index.spec.js~extendHex",
    "access": "public",
    "export": false,
    "importPath": "honeycomb-grid/src/hex/index.spec.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 11,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 103,
    "kind": "file",
    "name": "src/hex/prototype.js",
    "content": "import { ORIENTATION, EPSILON } from './constants'\nimport { offsetFromZero } from '../utils'\n\nconst sqrt3 = Math.sqrt(3)\n\n/**\n * @private\n */\nexport function setFactory({ Hex }) {\n    /**\n     * @memberof Hex#\n     * @instance\n     *\n     * @param {*} coordinates   Same parameters as the {@link Hex} factory.\n     * @returns {hex}           Itself with the passed parameters merged into it.\n     *\n     * @example\n     * const Hex = Honeycomb.extendHex()\n     *\n     * const hex = Hex({ x: 1, y: 2, a: 3, b: 4 })          // { a: 3, b: 4, x: 1, y: 2 }\n     * const updatedHex = hex.set({ x: 0, y: -1, b: 5 })    // { a: 3, b: 5, x: 0, y: -1 }\n     * hex === updatedHex                                   // true: hex is updated in-place\n     */\n    return function set(...args) {\n        return Object.assign(this, Hex(...args))\n    }\n}\n\n/**\n * @memberof Hex#\n * @returns {Object}    The hex's cartesian `x` and `y` coordinates.\n *\n * @example\n * const Hex = Honeycomb.extendHex()\n *\n * Hex().coordinates()      // { x: 0, y: 0 }\n * Hex(1, 2).coordinates()  // { x: 1, y: 2 }\n */\nexport function coordinates() {\n    return { x: this.x, y: this.y }\n}\n\n/**\n * @memberof Hex#\n * @returns {Object}    The hex's cube `q`, `r` and `s` coordinates.\n *\n * @example\n * const Hex = Honeycomb.extendHex()\n *\n * Hex().cube()     // { q: 0, r: 0, s: 0 }\n * Hex(1, 2).cube() // { q: 0, r: 2, s: -2 }\n */\nexport function cube() {\n    return { q: this.q, r: this.r, s: this.s }\n}\n\n/**\n * @memberof Hex#\n *\n * @todo make this a static (and instance?) method\n *\n * @param {Object} cubeCoordinates      At least the `q` and `r` cube coordinates.\n * @param {number} cubeCoordinates.q    The `q` cube coordinate.\n * @param {number} cubeCoordinates.r    The `r` cube coordinate.\n * @param {number} [cubeCoordinates.s]  The optional `s` cube coordinate.\n *\n * @returns {Object}                    The hex's cartesian `x` and `y` coordinates.\n *\n * @example\n * const Hex = Honeycomb.extendHex()\n *\n * Hex().cubeToCartesian({ q: 1, r: 2, s: -3 }) // { x: 2, y: 2 }\n * // the `s` coordinate isn't required:\n * Hex().cubeToCartesian({ q: -3, r: 5 })       // { x: -1, y: 5 }\n */\nexport function cubeToCartesian({ q, r }) {\n    let x, y\n\n    if (this.isPointy()) {\n        x = q + offsetFromZero(this.offset, r)\n        y = r\n    } else {\n        x = q\n        y = r + offsetFromZero(this.offset, q)\n    }\n\n    return { x, y }\n}\n\n/**\n * @memberof Hex#\n *\n * @todo make this a static (and instance?) method\n *\n * @param {Object} cartesianCoordinates     The `x` and `y` cartesian coordinate.\n * @param {number} cartesianCoordinates.x   The `x` cartesian coordinate.\n * @param {number} cartesianCoordinates.y   The `y` cartesian coordinate.\n *\n * @returns {Object}                        The hex's cube `q`, `r` and `s` coordinates.\n *\n * @example\n * const Hex = Honeycomb.extendHex()\n *\n * Hex().cartesianToCube({ x: 4, y: -2 }) // { q: 5, r: -2, s: -3 }\n */\nexport function cartesianToCube({ x, y }) {\n    let q, r\n\n    if (this.isPointy()) {\n        q = x - offsetFromZero(this.offset, y)\n        r = y\n    } else {\n        q = x\n        r = y - offsetFromZero(this.offset, x)\n    }\n\n    return { q, r, s: -q - r }\n}\n/**\n * @memberof Hex#\n * @returns {boolean}   Whether hexes have a pointy ⬢ orientation.\n */\nexport function isPointy() {\n    return this.orientation.toLowerCase() === ORIENTATION.pointy\n}\n\n/**\n * @memberof Hex#\n * @returns {boolean}   Whether hexes have a flat ⬣ orientation.\n */\nexport function isFlat() {\n    return this.orientation.toLowerCase() === ORIENTATION.flat\n}\n\n/**\n * @memberof Hex#\n * @returns {number}    The distance between opposite corners of a hex.\n */\nexport function oppositeCornerDistance() {\n    return this.size * 2\n}\n\n/**\n * @memberof Hex#\n * @returns {number}    The distance between opposite sides of a hex.\n */\nexport function oppositeSideDistance() {\n    return sqrt3 / 2 * this.oppositeCornerDistance()\n}\n\n/**\n * @memberof Hex#\n * @returns {number}    The (horizontal) width of a hex.\n */\nexport function width() {\n    return this.isPointy() ?\n        this.oppositeSideDistance() :\n        this.oppositeCornerDistance()\n}\n\n/**\n * @memberof Hex#\n * @returns {number}    The (vertical) height of a hex.\n */\nexport function height() {\n    return this.isPointy() ?\n        this.oppositeCornerDistance() :\n        this.oppositeSideDistance()\n}\n\n/**\n * @private\n */\nexport function cornersFactory({ Point }) {\n    /**\n     * @memberof Hex#\n     * @instance\n     * @returns {point[]}\n     * Array of corner points relative to the {@link Hex#origin|hex's origin}.\n     * Starting at the top right corner for pointy hexes and the right corner for flat hexes.\n     *\n     * @example\n     * // a hex's origin defaults to its top left corner (as if it's a rectangle)\n     * const Hex1 = Honeycomb.extendHex({ size: 30 })\n     * Hex1().corners() // [\n     *                  //    { x: 51.96152422706631, y: 15 },\n     *                  //    { x: 51.96152422706631, y: 45 },\n     *                  //    { x: 25.980762113533157, y: 60 },\n     *                  //    { x: 0, y: 45 },\n     *                  //    { x: 0, y: 15 },\n     *                  //    { x: 25.980762113533157, y: 0 }\n     *                  // ]\n     *\n     * // set the origin to a hex's center\n     * const Hex2 = Honeycomb.extendHex({ size: 30, origin: [25.980762113533157, 30] })\n     * Hex2().corners() // [\n     *                  //    { x: 25.980762113533157, y: -15 },\n     *                  //    { x: 25.980762113533157, y: 15 },\n     *                  //    { x: 0, y: 30 },\n     *                  //    { x: -25.980762113533157, y: 15 },\n     *                  //    { x: -25.980762113533157, y: -15 },\n     *                  //    { x: 0, y: -30 }\n     *                  // ]\n     */\n    return function corners() {\n        const width = this.width()\n        const height = this.height()\n        const { x, y } = this.origin\n\n        if (this.isPointy()) {\n            return [\n                Point(width - x, height * 0.25 - y),\n                Point(width - x, height * 0.75 - y),\n                Point(width * 0.5 - x, height - y),\n                Point(0 - x, height * 0.75 - y),\n                Point(0 - x, height * 0.25 - y),\n                Point(width * 0.5 - x, 0 - y)\n            ]\n        } else {\n            return [\n                Point(width - x, height * 0.5 - y),\n                Point(width * 0.75 - x, height - y),\n                Point(width * 0.25 - x, height - y),\n                Point(0 - x, height * 0.5 - y),\n                Point(width * 0.25 - x, 0 - y),\n                Point(width * 0.75 - x, 0 - y)\n            ]\n        }\n    }\n}\n\n/**\n * @private\n */\nexport function centerFactory({ Point }) {\n    /**\n     * @memberof Hex#\n     * @instance\n     * @returns {point} Point relative to the {@link Hex#origin|hex's origin}.\n     * Note that the default origin is the top left corner, so the default center is\n     * `{ x: hexWidth / 2, y: hexHeight / 2 }`.\n     *\n     * @example\n     * const Hex1 = Honeycomb.extendHex({ size: 10 })\n     * Hex1().center()  // { x: 8.660254037844386, y: 10 }\n     *\n     * const Hex2 = Honeycomb.extendHex({ size: 10, origin: [5, 5] })\n     * Hex2().center()  // { x: 3.6602540378443855, y: 5 }\n     */\n    return function center() {\n        const { x, y } = this.origin\n        return Point(this.width() / 2 - x, this.height() / 2 - y)\n    }\n}\n\n/**\n * @private\n */\nexport function toPointFactory({ Point }) {\n    /**\n     * @memberof Hex#\n     * @instance\n     * @returns {point} The hex's origin point.\n     *\n     * @example\n     * const Hex = Honeycomb.extendHex({ size: 30 })\n     * Hex().toPoint()          // { x: 0, y: 0 }\n     * Hex(-2, -5).toPoint()    // { x: -77.94228634059947, y: -225 }\n     */\n    return function toPoint() {\n        const { q, r, size } = this\n        let x, y\n\n        if (this.isPointy()) {\n            x = size * sqrt3 * (q + r / 2)\n            y = size * 3/2 * r\n        } else {\n            x = size * 3/2 * q\n            y = size * sqrt3 * (r + q / 2)\n        }\n\n        return Point(x, y)\n    }\n}\n\n/**\n * @private\n */\nexport function addFactory({ Hex, Point }) {\n    /**\n     * @memberof Hex#\n     * @instance\n     *\n     * @todo Accept any number of hexes to add.\n     *\n     * @param {point} point The hex (or point) that will be added to the current.\n     * @returns {hex}       A *new* hex where the passed hex's coordinates are added to the current.\n     *                      Any custom properties are copied.\n     */\n    return function add(point) {\n        const { x, y } = Point(point)\n        // use call() to bind any custom properties to Hex(), which get merged into the resulting hex.\n        return Hex.call(\n            this,\n            this.x + x,\n            this.y + y\n        )\n    }\n}\n\n/**\n * @private\n */\nexport function subtractFactory({ Hex, Point }) {\n    /**\n     * @memberof Hex#\n     * @instance\n     *\n     * @todo Accept any number of hexes to subtract.\n     *\n     * @param {point} point The hex (or point) that will be subtracted from the current.\n     * @returns {hex}       A *new* hex where the passed hex's coordinates are subtracted from the current.\n     *                      Any custom properties are copied.\n     */\n    return function subtract(point) {\n        const { x, y } = Point(point)\n        // use call() to bind any custom properties to Hex(), which get merged into the resulting hex.\n        return Hex.call(\n            this,\n            this.x - x,\n            this.y - y\n        )\n    }\n}\n\nexport function equalsFactory({ Point }) {\n    /**\n     * @memberof Hex#\n     * @instance\n     *\n     * @param {point} point The hex (or point) whose coordinates will be compared against the current hex.\n     * @returns {boolean}   Whether the coordinates of the current and the passed point are equal.\n     */\n    return function equals(point) {\n        const { x, y } = Point(point)\n        return this.x === x && this.y === y\n    }\n}\n\n/**\n * @memberof Hex#\n *\n * @see {@link https://www.redblobgames.com/grids/hexagons/#distances|redblobgames.com}\n *\n * @param   {hex} hex   The last hex (cannot be a {@link point}).\n * @returns {number}    The amount of hexes from the current to (and excluding) the last hex.\n *\n * @example\n * const Hex = Honeycomb.extendHex()\n *\n * Hex().distance(Hex(1, 0))        // 1\n * Hex(-2, -2).distance(Hex(4, 1))  // 8\n */\nexport function distance(hex) {\n    return Math.max(\n        Math.abs(this.q - hex.q),\n        Math.abs(this.r - hex.r),\n        Math.abs(this.s - hex.s)\n    )\n}\n\n/**\n * @private\n */\nexport function roundFactory({ Hex }) {\n    /**\n     * Rounds the current floating point hex coordinates to their nearest integer hex coordinates.\n     *\n     * @memberof Hex#\n     * @see {@link https://www.redblobgames.com/grids/hexagons/#rounding|redblobgames.com}\n     *\n     * @returns {hex}   A *new* hex with rounded coordinates.\n     *                  Any custom properties are copied.\n     *\n     * @example\n     * const Hex = Honeycomb.extendHex()\n     * Hex(3.1415, 0.5).round() // { x: 3, y: 1 }\n     */\n    return function round() {\n        let { q, r, s } = this\n        let roundedQ = Math.round(q)\n        let roundedR = Math.round(r)\n        let roundedS = Math.round(s)\n        const diffQ = Math.abs(q - roundedQ)\n        const diffR = Math.abs(r - roundedR)\n        const diffS = Math.abs(s - roundedS)\n\n        if (diffQ > diffR && diffQ > diffS) {\n            roundedQ = -roundedR - roundedS\n        } else if (diffR > diffS) {\n            roundedR = -roundedQ - roundedS\n        } else {\n            roundedS = -roundedQ - roundedR\n        }\n\n        // use call() to bind any custom properties to Hex(), which get merged into the resulting hex.\n        return Hex.call(this, { q: roundedQ, r: roundedR, s: roundedS })\n    }\n}\n\n/**\n * @private\n */\nexport function lerpFactory({ Hex }) {\n    /**\n     * Returns an interpolation between the current hex and the passed hex for a `t` between 0 and 1.\n     * More info on [wikipedia](https://en.wikipedia.org/wiki/Linear_interpolation).\n     *\n     * @memberof Hex#\n     *\n     * @param   {hex} hex   The other hex (cannot be a {@link point}).\n     * @param   {number} t  A \"parameter\" between 0 and 1.\n     *\n     * @returns {hex}       A new hex (likely with floating point coordinates).\n     *                      Any custom properties are copied.\n     */\n    return function lerp(hex, t) {\n        const q = this.q * (1 - t) + hex.q * t\n        const r = this.r * (1 - t) + hex.r * t\n        // use call() to bind any custom properties to Hex(), which get merged into the resulting hex.\n        return Hex.call(this, { q, r, s: -q - r })\n    }\n}\n\n/**\n * @memberof Hex#\n * @see {@link https://www.redblobgames.com/grids/hexagons/#line-drawing|redblobgames.com}\n *\n * @returns {hex}   A *new* hex with a tiny offset from the current hex.\n *                  Useful for interpolating in a consistent direction.\n */\nexport function nudge() {\n    return this.add(EPSILON)\n}\n\n/**\n * @memberof Hex#\n * @returns {string}    A string representation of the hex.\n */\nexport function toString() {\n    return `${this.x},${this.y}`\n}\n",
    "static": true,
    "longname": "/Users/abbe/Projects/honeycomb/src/hex/prototype.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 104,
    "kind": "variable",
    "name": "sqrt3",
    "memberof": "src/hex/prototype.js",
    "static": true,
    "longname": "src/hex/prototype.js~sqrt3",
    "access": "public",
    "export": false,
    "importPath": "honeycomb-grid/src/hex/prototype.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 105,
    "kind": "function",
    "name": "setFactory",
    "memberof": "src/hex/prototype.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/hex/prototype.js~setFactory",
    "access": "private",
    "export": true,
    "importPath": "honeycomb-grid/src/hex/prototype.js",
    "importStyle": "{setFactory}",
    "description": "",
    "lineNumber": 9,
    "ignore": true,
    "params": [
      {
        "name": "objectPattern",
        "types": [
          "{\"Hex\": *}"
        ],
        "defaultRaw": {
          "Hex": null
        },
        "defaultValue": "{\"Hex\":null}"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 106,
    "kind": "function",
    "name": "coordinates",
    "memberof": "src/hex/prototype.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/hex/prototype.js~coordinates",
    "access": "public",
    "export": true,
    "importPath": "honeycomb-grid/src/hex/prototype.js",
    "importStyle": "{coordinates}",
    "description": "",
    "examples": [
      "const Hex = Honeycomb.extendHex()\n\nHex().coordinates()      // { x: 0, y: 0 }\nHex(1, 2).coordinates()  // { x: 1, y: 2 }"
    ],
    "lineNumber": 39,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Object}    The hex's cartesian `x` and `y` coordinates."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "The hex's cartesian `x` and `y` coordinates."
    },
    "params": []
  },
  {
    "__docId__": 107,
    "kind": "function",
    "name": "cube",
    "memberof": "src/hex/prototype.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/hex/prototype.js~cube",
    "access": "public",
    "export": true,
    "importPath": "honeycomb-grid/src/hex/prototype.js",
    "importStyle": "{cube}",
    "description": "",
    "examples": [
      "const Hex = Honeycomb.extendHex()\n\nHex().cube()     // { q: 0, r: 0, s: 0 }\nHex(1, 2).cube() // { q: 0, r: 2, s: -2 }"
    ],
    "lineNumber": 53,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Object}    The hex's cube `q`, `r` and `s` coordinates."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "The hex's cube `q`, `r` and `s` coordinates."
    },
    "params": []
  },
  {
    "__docId__": 108,
    "kind": "function",
    "name": "cubeToCartesian",
    "memberof": "src/hex/prototype.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/hex/prototype.js~cubeToCartesian",
    "access": "public",
    "export": true,
    "importPath": "honeycomb-grid/src/hex/prototype.js",
    "importStyle": "{cubeToCartesian}",
    "description": "",
    "examples": [
      "const Hex = Honeycomb.extendHex()\n\nHex().cubeToCartesian({ q: 1, r: 2, s: -3 }) // { x: 2, y: 2 }\n// the `s` coordinate isn't required:\nHex().cubeToCartesian({ q: -3, r: 5 })       // { x: -1, y: 5 }"
    ],
    "lineNumber": 76,
    "todo": [
      "make this a static (and instance?) method"
    ],
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Object}                    The hex's cartesian `x` and `y` coordinates."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "cubeCoordinates",
        "description": "At least the `q` and `r` cube coordinates."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "cubeCoordinates.q",
        "description": "The `q` cube coordinate."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "cubeCoordinates.r",
        "description": "The `r` cube coordinate."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": true,
        "name": "cubeCoordinates.s",
        "description": "The optional `s` cube coordinate."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "The hex's cartesian `x` and `y` coordinates."
    }
  },
  {
    "__docId__": 109,
    "kind": "function",
    "name": "cartesianToCube",
    "memberof": "src/hex/prototype.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/hex/prototype.js~cartesianToCube",
    "access": "public",
    "export": true,
    "importPath": "honeycomb-grid/src/hex/prototype.js",
    "importStyle": "{cartesianToCube}",
    "description": "",
    "examples": [
      "const Hex = Honeycomb.extendHex()\n\nHex().cartesianToCube({ x: 4, y: -2 }) // { q: 5, r: -2, s: -3 }"
    ],
    "lineNumber": 106,
    "todo": [
      "make this a static (and instance?) method"
    ],
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Object}                        The hex's cube `q`, `r` and `s` coordinates."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "cartesianCoordinates",
        "description": "The `x` and `y` cartesian coordinate."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "cartesianCoordinates.x",
        "description": "The `x` cartesian coordinate."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "cartesianCoordinates.y",
        "description": "The `y` cartesian coordinate."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "The hex's cube `q`, `r` and `s` coordinates."
    }
  },
  {
    "__docId__": 110,
    "kind": "function",
    "name": "isPointy",
    "memberof": "src/hex/prototype.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/hex/prototype.js~isPointy",
    "access": "public",
    "export": true,
    "importPath": "honeycomb-grid/src/hex/prototype.js",
    "importStyle": "{isPointy}",
    "description": "",
    "lineNumber": 123,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{boolean}   Whether hexes have a pointy ⬢ orientation."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "Whether hexes have a pointy ⬢ orientation."
    },
    "params": []
  },
  {
    "__docId__": 111,
    "kind": "function",
    "name": "isFlat",
    "memberof": "src/hex/prototype.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/hex/prototype.js~isFlat",
    "access": "public",
    "export": true,
    "importPath": "honeycomb-grid/src/hex/prototype.js",
    "importStyle": "{isFlat}",
    "description": "",
    "lineNumber": 131,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{boolean}   Whether hexes have a flat ⬣ orientation."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "Whether hexes have a flat ⬣ orientation."
    },
    "params": []
  },
  {
    "__docId__": 112,
    "kind": "function",
    "name": "oppositeCornerDistance",
    "memberof": "src/hex/prototype.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/hex/prototype.js~oppositeCornerDistance",
    "access": "public",
    "export": true,
    "importPath": "honeycomb-grid/src/hex/prototype.js",
    "importStyle": "{oppositeCornerDistance}",
    "description": "",
    "lineNumber": 139,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number}    The distance between opposite corners of a hex."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "The distance between opposite corners of a hex."
    },
    "params": []
  },
  {
    "__docId__": 113,
    "kind": "function",
    "name": "oppositeSideDistance",
    "memberof": "src/hex/prototype.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/hex/prototype.js~oppositeSideDistance",
    "access": "public",
    "export": true,
    "importPath": "honeycomb-grid/src/hex/prototype.js",
    "importStyle": "{oppositeSideDistance}",
    "description": "",
    "lineNumber": 147,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number}    The distance between opposite sides of a hex."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "The distance between opposite sides of a hex."
    },
    "params": []
  },
  {
    "__docId__": 114,
    "kind": "function",
    "name": "width",
    "memberof": "src/hex/prototype.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/hex/prototype.js~width",
    "access": "public",
    "export": true,
    "importPath": "honeycomb-grid/src/hex/prototype.js",
    "importStyle": "{width}",
    "description": "",
    "lineNumber": 155,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number}    The (horizontal) width of a hex."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "The (horizontal) width of a hex."
    },
    "params": []
  },
  {
    "__docId__": 115,
    "kind": "function",
    "name": "height",
    "memberof": "src/hex/prototype.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/hex/prototype.js~height",
    "access": "public",
    "export": true,
    "importPath": "honeycomb-grid/src/hex/prototype.js",
    "importStyle": "{height}",
    "description": "",
    "lineNumber": 165,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number}    The (vertical) height of a hex."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "The (vertical) height of a hex."
    },
    "params": []
  },
  {
    "__docId__": 116,
    "kind": "function",
    "name": "cornersFactory",
    "memberof": "src/hex/prototype.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/hex/prototype.js~cornersFactory",
    "access": "private",
    "export": true,
    "importPath": "honeycomb-grid/src/hex/prototype.js",
    "importStyle": "{cornersFactory}",
    "description": "",
    "lineNumber": 174,
    "ignore": true,
    "params": [
      {
        "name": "objectPattern",
        "types": [
          "{\"Point\": *}"
        ],
        "defaultRaw": {
          "Point": null
        },
        "defaultValue": "{\"Point\":null}"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 117,
    "kind": "function",
    "name": "centerFactory",
    "memberof": "src/hex/prototype.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/hex/prototype.js~centerFactory",
    "access": "private",
    "export": true,
    "importPath": "honeycomb-grid/src/hex/prototype.js",
    "importStyle": "{centerFactory}",
    "description": "",
    "lineNumber": 235,
    "ignore": true,
    "params": [
      {
        "name": "objectPattern",
        "types": [
          "{\"Point\": *}"
        ],
        "defaultRaw": {
          "Point": null
        },
        "defaultValue": "{\"Point\":null}"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 118,
    "kind": "function",
    "name": "toPointFactory",
    "memberof": "src/hex/prototype.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/hex/prototype.js~toPointFactory",
    "access": "private",
    "export": true,
    "importPath": "honeycomb-grid/src/hex/prototype.js",
    "importStyle": "{toPointFactory}",
    "description": "",
    "lineNumber": 259,
    "ignore": true,
    "params": [
      {
        "name": "objectPattern",
        "types": [
          "{\"Point\": *}"
        ],
        "defaultRaw": {
          "Point": null
        },
        "defaultValue": "{\"Point\":null}"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 119,
    "kind": "function",
    "name": "addFactory",
    "memberof": "src/hex/prototype.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/hex/prototype.js~addFactory",
    "access": "private",
    "export": true,
    "importPath": "honeycomb-grid/src/hex/prototype.js",
    "importStyle": "{addFactory}",
    "description": "",
    "lineNumber": 289,
    "ignore": true,
    "params": [
      {
        "name": "objectPattern",
        "types": [
          "{\"Hex\": *, \"Point\": *}"
        ],
        "defaultRaw": {
          "Hex": null,
          "Point": null
        },
        "defaultValue": "{\"Hex\":null,\"Point\":null}"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 120,
    "kind": "function",
    "name": "subtractFactory",
    "memberof": "src/hex/prototype.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/hex/prototype.js~subtractFactory",
    "access": "private",
    "export": true,
    "importPath": "honeycomb-grid/src/hex/prototype.js",
    "importStyle": "{subtractFactory}",
    "description": "",
    "lineNumber": 314,
    "ignore": true,
    "params": [
      {
        "name": "objectPattern",
        "types": [
          "{\"Hex\": *, \"Point\": *}"
        ],
        "defaultRaw": {
          "Hex": null,
          "Point": null
        },
        "defaultValue": "{\"Hex\":null,\"Point\":null}"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 121,
    "kind": "function",
    "name": "equalsFactory",
    "memberof": "src/hex/prototype.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/hex/prototype.js~equalsFactory",
    "access": "public",
    "export": true,
    "importPath": "honeycomb-grid/src/hex/prototype.js",
    "importStyle": "{equalsFactory}",
    "description": null,
    "lineNumber": 336,
    "undocument": true,
    "params": [
      {
        "name": "objectPattern",
        "types": [
          "{\"Point\": *}"
        ],
        "defaultRaw": {
          "Point": null
        },
        "defaultValue": "{\"Point\":null}"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 122,
    "kind": "function",
    "name": "distance",
    "memberof": "src/hex/prototype.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/hex/prototype.js~distance",
    "access": "public",
    "export": true,
    "importPath": "honeycomb-grid/src/hex/prototype.js",
    "importStyle": "{distance}",
    "description": "",
    "examples": [
      "const Hex = Honeycomb.extendHex()\n\nHex().distance(Hex(1, 0))        // 1\nHex(-2, -2).distance(Hex(4, 1))  // 8"
    ],
    "see": [
      "{@link https://www.redblobgames.com/grids/hexagons/#distances|redblobgames.com}"
    ],
    "lineNumber": 364,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number}    The amount of hexes from the current to (and excluding) the last hex."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "hex"
        ],
        "spread": false,
        "optional": false,
        "name": "hex",
        "description": "The last hex (cannot be a {@link point})."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "The amount of hexes from the current to (and excluding) the last hex."
    }
  },
  {
    "__docId__": 123,
    "kind": "function",
    "name": "roundFactory",
    "memberof": "src/hex/prototype.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/hex/prototype.js~roundFactory",
    "access": "private",
    "export": true,
    "importPath": "honeycomb-grid/src/hex/prototype.js",
    "importStyle": "{roundFactory}",
    "description": "",
    "lineNumber": 375,
    "ignore": true,
    "params": [
      {
        "name": "objectPattern",
        "types": [
          "{\"Hex\": *}"
        ],
        "defaultRaw": {
          "Hex": null
        },
        "defaultValue": "{\"Hex\":null}"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 124,
    "kind": "function",
    "name": "lerpFactory",
    "memberof": "src/hex/prototype.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/hex/prototype.js~lerpFactory",
    "access": "private",
    "export": true,
    "importPath": "honeycomb-grid/src/hex/prototype.js",
    "importStyle": "{lerpFactory}",
    "description": "",
    "lineNumber": 414,
    "ignore": true,
    "params": [
      {
        "name": "objectPattern",
        "types": [
          "{\"Hex\": *}"
        ],
        "defaultRaw": {
          "Hex": null
        },
        "defaultValue": "{\"Hex\":null}"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 125,
    "kind": "function",
    "name": "nudge",
    "memberof": "src/hex/prototype.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/hex/prototype.js~nudge",
    "access": "public",
    "export": true,
    "importPath": "honeycomb-grid/src/hex/prototype.js",
    "importStyle": "{nudge}",
    "description": "",
    "see": [
      "{@link https://www.redblobgames.com/grids/hexagons/#line-drawing|redblobgames.com}"
    ],
    "lineNumber": 442,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{hex}   A *new* hex with a tiny offset from the current hex.\n                 Useful for interpolating in a consistent direction."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "hex"
      ],
      "spread": false,
      "description": "A *new* hex with a tiny offset from the current hex.\n                 Useful for interpolating in a consistent direction."
    },
    "params": []
  },
  {
    "__docId__": 126,
    "kind": "function",
    "name": "toString",
    "memberof": "src/hex/prototype.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/hex/prototype.js~toString",
    "access": "public",
    "export": true,
    "importPath": "honeycomb-grid/src/hex/prototype.js",
    "importStyle": "{toString}",
    "description": "",
    "lineNumber": 450,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string}    A string representation of the hex."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "A string representation of the hex."
    },
    "params": []
  },
  {
    "__docId__": 127,
    "kind": "file",
    "name": "src/hex/prototype.spec.js",
    "content": "/* eslint-env mocha */\n\nimport { expect } from 'chai'\nimport sinon from 'sinon'\n\nimport { ensureXY } from '../utils'\nimport PointFactory from '../point'\nimport { EPSILON } from './constants'\nimport extendHexFactory from './'\nimport * as methods from './prototype'\n\nconst extendHex = extendHexFactory({ ensureXY })\nconst Hex = extendHex()\nconst Point = PointFactory({ ensureXY })\n\ndescribe('set', () => {\n    let HexSpy, set\n\n    beforeEach(function() {\n        HexSpy = sinon.spy(Hex)\n        set = methods.setFactory({ Hex: HexSpy })\n    })\n\n    it('passes any arguments to the Hex() factory', () => {\n        set.call({}, 1, 2)\n        expect(HexSpy).to.have.been.calledWithExactly(1, 2)\n\n        set.call({}, { x: 1, y: 2 })\n        expect(HexSpy).to.have.been.calledWithExactly({ x: 1, y: 2 })\n\n        set.call({}, 'invalid argument')\n        expect(HexSpy).to.have.been.calledWithExactly('invalid argument')\n    })\n\n    it('merges the return value of Hex() into itself', () => {\n        const self = { x: 1, y: 2 }\n\n        set.call(self, { x: 5, y: -2 })\n        expect(self).to.eql({ x: 5, y: -2 })\n\n        set.call(self)\n        expect(self).to.eql({ x: 0, y: 0 })\n    })\n\n    it('returns itself', () => {\n        const self = { x: 1, y: 2 }\n        const result = set.call(self)\n\n        expect(result).to.equal(self)\n    })\n})\n\ndescribe('coordinates', function() {\n    it('returns the hex\\'s x and y coordinates', function() {\n        const boundCoordinates = methods.coordinates.bind({ x: 8, y: -3 })\n        expect(boundCoordinates()).to.eql({ x: 8, y: -3 })\n    })\n})\n\ndescribe('cubeToCartesian', () => {\n    describe('when the hex has a pointy orientation', () => {\n        it('converts the passed cube coordinates to rectangular coordinates', () => {\n            const isPointy = sinon.stub().returns(true)\n            let cubeToCartesian = methods.cubeToCartesian.bind({ isPointy, offset: -1 })\n            expect(cubeToCartesian({ q: 2, r: 1, s: -3 })).to.eql({ x: 2, y: 1 })\n            cubeToCartesian = methods.cubeToCartesian.bind({ isPointy, offset: 1 })\n            expect(cubeToCartesian({ q: 2, r: 1, s: -3 })).to.eql({ x: 3, y: 1 })\n        })\n    })\n\n    describe('when the hex has a flat orientation', () => {\n        it('converts the passed cube coordinates to rectangular coordinates', () => {\n            const isPointy = sinon.stub().returns(false)\n            let cubeToCartesian = methods.cubeToCartesian.bind({ isPointy, offset: -1 })\n            expect(cubeToCartesian({ q: 1, r: 1, s: -2 })).to.eql({ x: 1, y: 1 })\n            cubeToCartesian = methods.cubeToCartesian.bind({ isPointy, offset: 1 })\n            expect(cubeToCartesian({ q: 1, r: 1, s: -2 })).to.eql({ x: 1, y: 2 })\n        })\n    })\n})\n\ndescribe('cartesianToCube', () => {\n    describe('when the hex has a pointy orientation', () => {\n        it('converts the passed rectangular coordinates to cube coordinates', () => {\n            const isPointy = sinon.stub().returns(true)\n            let cartesianToCube = methods.cartesianToCube.bind({ isPointy, offset: -1 })\n            expect(cartesianToCube({ x: 2, y: 1 })).to.eql({ q: 2, r: 1, s: -3 })\n            cartesianToCube = methods.cartesianToCube.bind({ isPointy, offset: 1 })\n            expect(cartesianToCube({ x: 2, y: 1 })).to.eql({ q: 1, r: 1, s: -2 })\n        })\n    })\n\n    describe('when the hex has a flat orientation', () => {\n        it('converts the passed rectangular coordinates to cube coordinates', () => {\n            const isPointy = sinon.stub().returns(false)\n            let cartesianToCube = methods.cartesianToCube.bind({ isPointy, offset: -1 })\n            expect(cartesianToCube({ x: 1, y: 1 })).to.eql({ q: 1, r: 1, s: -2 })\n            cartesianToCube = methods.cartesianToCube.bind({ isPointy, offset: 1 })\n            expect(cartesianToCube({ x: 1, y: 1 })).to.eql({ q: 1, r: 0, s: -1 })\n        })\n    })\n})\n\ndescribe('isPointy', function() {\n    it('returns whether the hex has a pointy orientation', function() {\n        let isPointy = methods.isPointy.bind({ orientation: 'pointy' })\n        expect(isPointy()).to.be.true\n        isPointy = methods.isPointy.bind({ orientation: 'pointy' })\n        expect(isPointy()).to.be.true\n        isPointy = methods.isPointy.bind({ orientation: 'flat' })\n        expect(isPointy()).to.be.false\n    })\n})\n\ndescribe('isFlat', function() {\n    it('returns whether the hex has a flat orientation', function() {\n        let isFlat = methods.isFlat.bind({ orientation: 'flat' })\n        expect(isFlat()).to.be.true\n        isFlat = methods.isFlat.bind({ orientation: 'flat' })\n        expect(isFlat()).to.be.true\n        isFlat = methods.isFlat.bind({ orientation: 'pointy' })\n        expect(isFlat()).to.be.false\n    })\n})\n\ndescribe('oppositeCornerDistance', function() {\n    it('returns the distance between two opposite corners of the hex', function() {\n        const oppositeCornerDistance = methods.oppositeCornerDistance.bind({ size: 1 })\n        expect(oppositeCornerDistance()).to.equal(2)\n    })\n})\n\ndescribe('oppositeSideDistance', function() {\n    it('returns the distance between two opposite sides of a hex', function() {\n        const oppositeCornerDistance = sinon.stub().returns(1)\n        const oppositeSideDistance = methods.oppositeSideDistance.bind({ oppositeCornerDistance })\n        const result = oppositeSideDistance()\n\n        expect(oppositeCornerDistance).to.have.been.called\n        expect(result).to.be.closeTo(0.8660, 0.0005)\n    })\n})\n\ndescribe('width', function() {\n    beforeEach(function() {\n        sinon.stub(methods, 'isPointy')\n    })\n    afterEach(function() {\n        methods.isPointy.restore()\n    })\n\n    describe('when the hex has a pointy orientation', function() {\n        it('returns Hex.oppositeSideDistance()', function() {\n            methods.isPointy.returns(true)\n            sinon.spy(methods, 'oppositeSideDistance')\n\n            methods.width()\n            expect(methods.oppositeSideDistance).to.have.been.called\n\n            methods.oppositeSideDistance.restore()\n        })\n    })\n\n    describe('when the hex has a flat orientation', function() {\n        it('returns Hex.oppositeCornerDistance()', function() {\n            methods.isPointy.returns(false)\n            sinon.spy(methods, 'oppositeCornerDistance')\n\n            methods.width()\n            expect(methods.oppositeCornerDistance).to.have.been.called\n\n            methods.oppositeCornerDistance.restore()\n        })\n    })\n})\n\ndescribe('height', function() {\n    beforeEach(function() {\n        sinon.stub(methods, 'isPointy')\n    })\n    afterEach(function() {\n        methods.isPointy.restore()\n    })\n\n    describe('when the hex has a pointy orientation', function() {\n        it('returns Hex.oppositeCornerDistance()', function() {\n            methods.isPointy.returns(true)\n            sinon.spy(methods, 'oppositeCornerDistance')\n\n            methods.height()\n            expect(methods.oppositeCornerDistance).to.have.been.called\n\n            methods.oppositeCornerDistance.restore()\n        })\n    })\n\n    describe('when the hex has a flat orientation', function() {\n        it('returns Hex.oppositeSideDistance()', function() {\n            methods.isPointy.returns(false)\n            sinon.spy(methods, 'oppositeSideDistance')\n\n            methods.height()\n            expect(methods.oppositeSideDistance).to.have.been.called\n\n            methods.oppositeSideDistance.restore()\n        })\n    })\n})\n\ndescribe('corners', function() {\n    let width, height, isPointy, Point, corners, context\n\n    beforeEach(function() {\n        width = sinon.stub().returns(2)\n        height = sinon.stub().returns(2)\n        isPointy = sinon.stub()\n        Point = sinon.stub().callsFake((x, y) => ({ x, y }))\n        corners = methods.cornersFactory({ Point })\n        context = {\n            origin: {},\n            width,\n            height,\n            isPointy\n        }\n    })\n\n    it('calls the hex\\'s witdh(), height() and isPointy() methods', function() {\n        corners.call(context)\n        expect(width).to.have.been.called\n        expect(height).to.have.been.called\n        expect(isPointy).to.have.been.called\n    })\n\n    describe('when the hex has a pointy orientation', function() {\n        beforeEach(function() {\n            isPointy.returns(true)\n        })\n\n        it('returns an array of 6 corners relative to origin', function() {\n            context.origin = { x: 1, y: 1 }\n            const result = corners.call(context)\n\n            expect(result).to.have.lengthOf(6)\n            expect(Point.getCall(0).args).to.eql([1, -0.5])\n            expect(Point.getCall(1).args).to.eql([1, 0.5])\n            expect(Point.getCall(2).args).to.eql([0, 1])\n            expect(Point.getCall(3).args).to.eql([-1, 0.5])\n            expect(Point.getCall(4).args).to.eql([-1, -0.5])\n            expect(Point.getCall(5).args).to.eql([0, -1])\n        })\n    })\n\n    describe('when the hex has a flat orientation', function() {\n        beforeEach(function() {\n            isPointy.returns(false)\n        })\n\n        it('returns an array of 6 corners relative to origin', function() {\n            context.origin = { x: 1, y: 1 }\n            const result = corners.call(context)\n\n            expect(result).to.have.lengthOf(6)\n            expect(Point.getCall(0).args).to.eql([1, 0])\n            expect(Point.getCall(1).args).to.eql([0.5, 1])\n            expect(Point.getCall(2).args).to.eql([-0.5, 1])\n            expect(Point.getCall(3).args).to.eql([-1, 0])\n            expect(Point.getCall(4).args).to.eql([-0.5, -1])\n            expect(Point.getCall(5).args).to.eql([0.5, -1])\n        })\n    })\n})\n\ndescribe('toPoint', function() {\n    let Point, toPoint, isPointy, context\n\n    beforeEach(function() {\n        Point = sinon.stub().returns('point result')\n        toPoint = methods.toPointFactory({ Point })\n        isPointy = sinon.stub()\n        context = {\n            q: 1,\n            r: 1,\n            size: 1,\n            isPointy\n        }\n    })\n\n    it('returns the point', function() {\n        const result = toPoint.call(context)\n        expect(result).to.eql('point result')\n    })\n\n    describe('when the hex has a pointy orientation', function() {\n        beforeEach(function() {\n            isPointy.returns(true)\n        })\n\n        it('creates a new point', function() {\n            toPoint.call(context)\n            expect(Point.firstCall.args[0]).to.be.closeTo(2.5980, 0.0005)\n            expect(Point.firstCall.args[1]).to.equal(1.5)\n        })\n    })\n\n    describe('when the hex has a flat orientation', function() {\n        beforeEach(function() {\n            isPointy.returns(false)\n        })\n\n        it('creates a new point', function() {\n            toPoint.call(context)\n            expect(Point.firstCall.args[0]).to.equal(1.5)\n            expect(Point.firstCall.args[1]).to.be.closeTo(2.5980, 0.0005)\n        })\n    })\n})\n\ndescribe('add', function () {\n    let HexSpy, PointSpy, add\n\n    before(function () {\n        HexSpy = sinon.spy(Hex)\n        PointSpy = sinon.spy(Point)\n        add = methods.addFactory({ Hex: HexSpy, Point: PointSpy }).bind({ x: 1, y: -3 })\n    })\n\n    it('accepts a point', () => {\n        expect(add([2, 1])).to.contain({ x: 3, y: -2 })\n        expect(PointSpy).to.have.been.calledWith([2, 1])\n    })\n\n    it('returns a new hex where the coordinates are the sum of the current and passed point', function () {\n        expect(add(Hex(2, 1))).to.contain({ x: 3, y: -2 })\n        expect(HexSpy).to.have.been.calledWith(3, -2)\n    })\n\n    it('transfers any custom properties the current hex might have', function() {\n        const result = Hex.call({ x: 0, y: 0, custom: 'add()' }).add(Hex())\n        expect(result).to.contain({ custom: 'add()' })\n    })\n})\n\ndescribe('subtract', function() {\n    let HexSpy, PointSpy, subtract\n\n    before(function() {\n        HexSpy = sinon.spy(Hex)\n        PointSpy = sinon.spy(Point)\n        subtract = methods.subtractFactory({ Hex: HexSpy, Point: PointSpy }).bind({ x: 1, y: -3 })\n    })\n\n    it('accepts a point', () => {\n        expect(subtract([2, 1])).to.contain({ x: -1, y: -4 })\n        expect(PointSpy).to.have.been.calledWith([2, 1])\n    })\n\n    it('returns a new hex where the coordinates are the sum of the current and passed point', function() {\n        expect(subtract(Hex(2, 1))).to.contain({ x: -1, y: -4 })\n        expect(HexSpy).to.have.been.calledWith(-1, -4)\n    })\n\n    it('transfers any custom properties the current hex might have', function() {\n        const result = Hex.call({ x: 0, y: 0, custom: 'subtract()' }).subtract(Hex())\n        expect(result).to.contain({ custom: 'subtract()' })\n    })\n})\n\ndescribe('equals', function () {\n    it('accepts a point', () => {\n        expect(Hex().equals([0, 0])).to.be.true\n    })\n\n    it('returns whether the coordinates of the current hex and the passed point are equal', function() {\n        expect(Hex().equals(Hex())).to.be.true\n        expect(Hex(5, -3).equals(Hex(-1, 2))).to.be.false\n    })\n\n    it('ignores any custom properties', function() {\n        const hex1 = Hex.call({ custom: 1 }, 4, 4)\n        const hex2 = Hex.call({ custom: 2 }, 4, 4)\n\n        expect(hex1.equals(hex2)).to.be.true\n    })\n})\n\ndescribe('distance', function () {\n    it('returns the highest absolute coordinate of the other hex coordinates subtracted from the current', function () {\n        const distance = methods.distance.bind({ q: 1, r: 2, s: -3 })\n        expect(distance({ q: 1, r: 1, s: 1 })).to.equal(4)\n    })\n})\n\ndescribe('round', function () {\n    let HexStub, round\n\n    before(function () {\n        HexStub = sinon.stub().returnsThis()\n        round = methods.roundFactory({ Hex: HexStub }).bind({ q: 2.9, r: 2.2, s: -5.1, custom: 'round()' })\n    })\n\n    it('rounds floating point coordinates to their nearest integer coordinates', function () {\n        round()\n        expect(HexStub).to.have.been.calledWith({ q: 3, r: 2, s: -5 })\n    })\n\n    it('transfers any custom properties the current hex might have', function() {\n        expect(round()).to.have.property('custom', 'round()')\n    })\n})\n\ndescribe('lerp', function () {\n    let HexStub, lerp\n\n    before(function() {\n        HexStub = sinon.stub().returnsThis()\n        lerp = methods.lerpFactory({ Hex: HexStub }).bind({ q: 0, r: 0, s: 0, custom: 'lerp()' })\n    })\n\n    it('returns an interpolation between the current and passed hex for a `t` between 0..1', function () {\n        lerp({ q: 4, r: -5, s: 1 }, 0.5)\n        expect(HexStub).to.have.been.calledWith({ q: 2, r: -2.5, s: 0.5 })\n    })\n\n    it('transfers any custom properties the current hex might have', function() {\n        expect(lerp({})).to.have.property('custom', 'lerp()')\n    })\n})\n\ndescribe('nudge', function () {\n    it('returns the current hex with a tiny offset', function () {\n        const add = sinon.stub().returns('add result')\n        const nudge = methods.nudge.bind({ add })\n        const result = nudge()\n        expect(add).to.have.been.calledWith(EPSILON)\n        expect(result).to.eql('add result')\n    })\n\n    it('transfers any custom properties the current hex might have', function() {\n        const result = Hex.call({ custom: 'nudge()' }).nudge()\n        expect(result).to.have.property('custom', 'nudge()')\n    })\n})\n\ndescribe('toString', function() {\n    it('returns a string containing the coordinates of the hex', function() {\n        expect(Hex(1, 2).toString()).to.eql('1,2')\n    })\n})\n\ndescribe('center', () => {\n    it(`returns a hex's center point relative to its origin`, () => {\n        let Hex = extendHex()\n        let result = Hex().center()\n\n        expect(result.x).to.be.closeTo(0.8660, 0.0005)\n        expect(result.y).to.equal(1)\n\n        Hex = extendHex({ size: 10, origin: [5,5] })\n        result = Hex().center()\n        expect(result.x).to.be.closeTo(3.6602, 0.005)\n        expect(result.y).to.equal(5)\n    })\n})\n",
    "static": true,
    "longname": "/Users/abbe/Projects/honeycomb/src/hex/prototype.spec.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 128,
    "kind": "variable",
    "name": "extendHex",
    "memberof": "src/hex/prototype.spec.js",
    "static": true,
    "longname": "src/hex/prototype.spec.js~extendHex",
    "access": "public",
    "export": false,
    "importPath": "honeycomb-grid/src/hex/prototype.spec.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 12,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 129,
    "kind": "variable",
    "name": "Hex",
    "memberof": "src/hex/prototype.spec.js",
    "static": true,
    "longname": "src/hex/prototype.spec.js~Hex",
    "access": "public",
    "export": false,
    "importPath": "honeycomb-grid/src/hex/prototype.spec.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 13,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 130,
    "kind": "variable",
    "name": "Point",
    "memberof": "src/hex/prototype.spec.js",
    "static": true,
    "longname": "src/hex/prototype.spec.js~Point",
    "access": "public",
    "export": false,
    "importPath": "honeycomb-grid/src/hex/prototype.spec.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 14,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 131,
    "kind": "file",
    "name": "src/hex/statics.js",
    "content": "/**\n * Calculates the third cube coordinate from the other two. The sum of all three coordinates must be 0.\n *\n * @memberof Hex\n * @static\n *\n * @param {number} firstCoordinate  The first other cube coordinate.\n * @param {number} secondCoordinate The second other cube coordinate.\n *\n * @returns {number}                The third cube coordinate.\n *\n * @example\n * const Hex = Honeycomb.extendHex()\n * Hex.thirdCoordinate(3, -2)   // -1\n */\nexport function thirdCoordinate(firstCoordinate, secondCoordinate) {\n    return -firstCoordinate - secondCoordinate\n}\n",
    "static": true,
    "longname": "/Users/abbe/Projects/honeycomb/src/hex/statics.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 132,
    "kind": "function",
    "name": "thirdCoordinate",
    "memberof": "src/hex/statics.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/hex/statics.js~thirdCoordinate",
    "access": "public",
    "export": true,
    "importPath": "honeycomb-grid/src/hex/statics.js",
    "importStyle": "{thirdCoordinate}",
    "description": "Calculates the third cube coordinate from the other two. The sum of all three coordinates must be 0.",
    "examples": [
      "const Hex = Honeycomb.extendHex()\nHex.thirdCoordinate(3, -2)   // -1"
    ],
    "lineNumber": 16,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number}                The third cube coordinate."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "firstCoordinate",
        "description": "The first other cube coordinate."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "secondCoordinate",
        "description": "The second other cube coordinate."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "The third cube coordinate."
    }
  },
  {
    "__docId__": 133,
    "kind": "file",
    "name": "src/hex/statics.spec.js",
    "content": "/* eslint-env mocha */\n\nimport { expect } from 'chai'\n\nimport * as statics from './statics'\n\ndescribe('Hex static methods', function() {\n    describe('thirdCoordinate', function() {\n        it('returns the result of -firstCoordinate - secondCoordinate', function() {\n            expect(statics.thirdCoordinate(3, -1)).to.equal(-2)\n        })\n    })\n})\n",
    "static": true,
    "longname": "/Users/abbe/Projects/honeycomb/src/hex/statics.spec.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 134,
    "kind": "file",
    "name": "src/honeycomb.js",
    "content": "import { ensureXY } from './utils'\nimport extendHexFactory from './hex'\nimport defineGridFactory from './grid'\nimport PointFactory from './point'\n\n/** @ignore */\nconst extendHex = extendHexFactory({ ensureXY })\n/** @ignore */\nconst defineGrid = defineGridFactory({ extendHex })\n/** @ignore */\nconst Point = PointFactory({ ensureXY })\n\n/**\n * @namespace {Object} Honeycomb\n */\nexport {\n    extendHex,\n    defineGrid,\n    Point\n}\n",
    "static": true,
    "longname": "/Users/abbe/Projects/honeycomb/src/honeycomb.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 135,
    "kind": "variable",
    "name": "extendHex",
    "memberof": "src/honeycomb.js",
    "static": true,
    "longname": "src/honeycomb.js~extendHex",
    "access": "public",
    "export": true,
    "importPath": "honeycomb-grid/src/honeycomb.js",
    "importStyle": "{extendHex}",
    "description": null,
    "lineNumber": 7,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 136,
    "kind": "variable",
    "name": "defineGrid",
    "memberof": "src/honeycomb.js",
    "static": true,
    "longname": "src/honeycomb.js~defineGrid",
    "access": "public",
    "export": true,
    "importPath": "honeycomb-grid/src/honeycomb.js",
    "importStyle": "{defineGrid}",
    "description": null,
    "lineNumber": 9,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 137,
    "kind": "variable",
    "name": "Point",
    "memberof": "src/honeycomb.js",
    "static": true,
    "longname": "src/honeycomb.js~Point",
    "access": "public",
    "export": true,
    "importPath": "honeycomb-grid/src/honeycomb.js",
    "importStyle": "{Point}",
    "description": null,
    "lineNumber": 11,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 138,
    "kind": "file",
    "name": "src/honeycomb.spec.js",
    "content": "/* eslint-env mocha */\n\nimport { expect } from 'chai'\n\nimport * as API from './honeycomb'\n\ndescribe('API', function() {\n    it('has a extendHex function', function() {\n        expect(API).to.have.property('extendHex').that.is.a('function').with.property('name', 'extendHex')\n    })\n\n    it('has a defineGrid function', function() {\n        expect(API).to.have.property('defineGrid').that.is.a('function').with.property('name', 'defineGrid')\n    })\n\n    it('exposes the Point factory', function() {\n        expect(API).to.have.property('Point').that.is.a('function').with.property('name', 'Point')\n    })\n})\n",
    "static": true,
    "longname": "/Users/abbe/Projects/honeycomb/src/honeycomb.spec.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 139,
    "kind": "file",
    "name": "src/point/index.js",
    "content": "import { isNumber, isArray, isObject } from 'axis.js'\nimport * as methods from './prototype'\n\n/**\n * See {@link Point}.\n *\n * @function Point\n * @memberof Honeycomb\n * @static\n */\n\nexport default function PointFactory({ ensureXY }) {\n    const prototype = {\n        add: methods.addFactory({ Point }),\n        subtract: methods.subtractFactory({ Point }),\n        multiply: methods.multiplyFactory({ Point }),\n        divide: methods.divideFactory({ Point })\n    }\n\n    /**\n     * Factory function for creating two-dimensional points.\n     *\n     * @function Point\n     *\n     * @param {(number|number[]|point)} [pointOrX=] The x coordinate or an array with 2 numbers or an object with an `x` and `y` coordinate.\n     * @param {number} [pointOrX.x=]                The x coordinate.\n     * @param {number} [pointOrX.y=]                The y coordinate.\n     * @param {number} [y=]                         The y coordinate.\n     *\n     * @returns {point}                             A point.\n     *\n     * @example\n     * const Point = Honeycomb.Point\n     *\n     * Point()                  // { x: 0, y: 0 }\n     * Point(1)                 // { x: 1, y: 1 }\n     * Point(1, 2)              // { x: 1, y: 2 }\n     *\n     * Point([])                // { x: 0, y: 0 }\n     * Point([1])               // { x: 1, y: 1 }\n     * Point([1, 2])            // { x: 1, y: 2 }\n     *\n     * Point({})                // { x: 0, y: 0 }\n     * Point({ x: 1 })          // { x: 1, y: 1 }\n     * Point({ y: 2 })          // { x: 2, y: 2 }\n     * Point({ x: 1, y: 2 })    // { x: 1, y: 2 }\n     */\n    function Point(pointOrX, y) {\n        let coordinates\n        /**\n         * An object with just an `x` and a `y` property.\n         *\n         * Create your own:\n         * ```javascript\n         * const point = { x: 1, y: 2 }\n         * ```\n         *\n         * Or use the included {@link Point} factory:\n         * ```javascript\n         * const point = Honeycomb.Point(1, 2)\n         * ```\n         *\n         * @typedef {Object} point\n         * @property {number} x (horizontal) x coordinate\n         * @property {number} y (vertical) y coordinate\n         */\n\n        if (isNumber(pointOrX)) {\n            coordinates = ensureXY(pointOrX, y)\n        } else if (isArray(pointOrX)) {\n            coordinates = ensureXY(...pointOrX)\n        } else if (isObject(pointOrX)) {\n            coordinates = ensureXY(pointOrX.x, pointOrX.y)\n        } else {\n            coordinates = ensureXY(0)\n        }\n\n        return Object.assign(\n            Object.create(prototype),\n            coordinates\n        )\n    }\n\n    return Point\n}\n",
    "static": true,
    "longname": "/Users/abbe/Projects/honeycomb/src/point/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 140,
    "kind": "function",
    "name": "PointFactory",
    "memberof": "src/point/index.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/point/index.js~PointFactory",
    "access": "public",
    "export": true,
    "importPath": "honeycomb-grid/src/point/index.js",
    "importStyle": "PointFactory",
    "description": "See {@link Point}.",
    "lineNumber": 12,
    "unknown": [
      {
        "tagName": "@function",
        "tagValue": "Point"
      }
    ],
    "params": [
      {
        "name": "objectPattern",
        "types": [
          "{\"ensureXY\": *}"
        ],
        "defaultRaw": {
          "ensureXY": null
        },
        "defaultValue": "{\"ensureXY\":null}"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 141,
    "kind": "typedef",
    "name": "point",
    "memberof": "src/point/index.js",
    "static": true,
    "longname": "src/point/index.js~point",
    "access": "public",
    "description": "An object with just an `x` and a `y` property.\n\nCreate your own:\n```javascript\nconst point = { x: 1, y: 2 }\n```\n\nOr use the included {@link Point} factory:\n```javascript\nconst point = Honeycomb.Point(1, 2)\n```",
    "lineNumber": 68,
    "properties": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "x",
        "description": "(horizontal) x coordinate"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "y",
        "description": "(vertical) y coordinate"
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "point"
    }
  },
  {
    "__docId__": 142,
    "kind": "file",
    "name": "src/point/index.spec.js",
    "content": "/* eslint-env mocha */\n\nimport { expect } from 'chai'\nimport sinon from 'sinon'\n\nimport { ensureXY } from '../utils'\nimport PointFactory from './'\n\nconst ensureXYSpy = sinon.spy(ensureXY)\nconst Point = PointFactory({ ensureXY: ensureXYSpy })\n\ndescribe('Point creation', function() {\n    it('calls ensureXY', () => {\n        Point(1, 2)\n        expect(ensureXYSpy).to.have.been.calledWith(1, 2)\n    })\n\n    describe('with 2 numbers', function() {\n        it('sets the coordinates', function() {\n            expect(Point(3, 2)).to.contain({ x: 3, y: 2 })\n            expect(Point(-3, -2)).to.contain({ x: -3, y: -2 })\n            expect(Point(3.375, 2.950)).to.contain({ x: 3.375, y: 2.950 })\n        })\n    })\n\n    describe('with 1 number', function() {\n        it('assumes the number is the x coordinate and sets y to the same value', function() {\n            expect(Point(3)).to.contain({ x: 3, y: 3 })\n        })\n    })\n\n    describe('with an object containing x and y', function() {\n        it('sets the coordinates', function() {\n            expect(Point({ x: 3, y: 2 })).to.contain({ x: 3, y: 2 })\n        })\n    })\n\n    describe('with an object containing only x or y', function() {\n        it('sets the missing coordinate to the passed coordinate', function() {\n            expect(Point({ x: 3 })).to.contain({ x: 3, y: 3 })\n            expect(Point({ y: 2 })).to.contain({ x: 2, y: 2 })\n        })\n    })\n\n    describe('with an empty empty', function() {\n        it('sets both coordinates to 0', function() {\n            expect(Point({})).to.contain({ x: 0, y: 0 })\n        })\n    })\n\n    describe('with an array containing 2 numbers', function() {\n        it('sets the coordinates', function() {\n            expect(Point([ 3, 2 ])).to.contain({ x: 3, y: 2 })\n        })\n    })\n\n    describe('with an array containing 1 number', function() {\n        it('assumes the number is the x coordinate and sets y to the same value', function() {\n            expect(Point([ 3 ])).to.contain({ x: 3, y: 3 })\n        })\n    })\n\n    describe('with an empty array', function() {\n        it('sets both coordinates to 0', function() {\n            expect(Point([])).to.contain({ x: 0, y: 0 })\n        })\n    })\n\n    describe('without parameters', function() {\n        it('sets both coordinates to 0', function() {\n            expect(Point()).to.contain({ x: 0, y: 0 })\n        })\n    })\n})\n",
    "static": true,
    "longname": "/Users/abbe/Projects/honeycomb/src/point/index.spec.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 143,
    "kind": "variable",
    "name": "ensureXYSpy",
    "memberof": "src/point/index.spec.js",
    "static": true,
    "longname": "src/point/index.spec.js~ensureXYSpy",
    "access": "public",
    "export": false,
    "importPath": "honeycomb-grid/src/point/index.spec.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 144,
    "kind": "variable",
    "name": "Point",
    "memberof": "src/point/index.spec.js",
    "static": true,
    "longname": "src/point/index.spec.js~Point",
    "access": "public",
    "export": false,
    "importPath": "honeycomb-grid/src/point/index.spec.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 145,
    "kind": "file",
    "name": "src/point/prototype.js",
    "content": "export function addFactory({ Point }) {\n    /**\n     * @memberof Point#\n\n     * @param   {point} point   The point to add to the current point.\n     * @returns {point}         The sum of the passed point's coordinates to the current point's.\n     */\n    return function add(point) {\n        return Point(this.x + point.x, this.y + point.y)\n    }\n}\n\nexport function subtractFactory({ Point }) {\n    /**\n     * @memberof Point#\n     *\n     * @param   {point} point   The point to subtract from the current point.\n     * @returns {point}         The difference between the passed point's coordinates and the current point's.\n     */\n    return function subtract(point) {\n        return Point(this.x - point.x, this.y - point.y)\n    }\n}\n\nexport function multiplyFactory({ Point }) {\n    /**\n     * @memberof Point#\n     *\n     * @param   {point} point   The point to multiply with the current point.\n     * @returns {point}         The multiplication of the passed point's coordinates and the current point's.\n     */\n    return function multiply(point) {\n        return Point(this.x * point.x, this.y * point.y)\n    }\n}\n\nexport function divideFactory({ Point }) {\n    /**\n     * @memberof Point#\n     *\n     * @param   {point} point   The point where the current point is divided by.\n     * @returns {point}         The division of the current point's coordinates and the passed point's.\n     */\n    return function divide(point) {\n        return Point(this.x / point.x, this.y / point.y)\n    }\n}\n",
    "static": true,
    "longname": "/Users/abbe/Projects/honeycomb/src/point/prototype.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 146,
    "kind": "function",
    "name": "addFactory",
    "memberof": "src/point/prototype.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/point/prototype.js~addFactory",
    "access": "public",
    "export": true,
    "importPath": "honeycomb-grid/src/point/prototype.js",
    "importStyle": "{addFactory}",
    "description": null,
    "lineNumber": 1,
    "undocument": true,
    "params": [
      {
        "name": "objectPattern",
        "types": [
          "{\"Point\": *}"
        ],
        "defaultRaw": {
          "Point": null
        },
        "defaultValue": "{\"Point\":null}"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 147,
    "kind": "function",
    "name": "subtractFactory",
    "memberof": "src/point/prototype.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/point/prototype.js~subtractFactory",
    "access": "public",
    "export": true,
    "importPath": "honeycomb-grid/src/point/prototype.js",
    "importStyle": "{subtractFactory}",
    "description": null,
    "lineNumber": 13,
    "undocument": true,
    "params": [
      {
        "name": "objectPattern",
        "types": [
          "{\"Point\": *}"
        ],
        "defaultRaw": {
          "Point": null
        },
        "defaultValue": "{\"Point\":null}"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 148,
    "kind": "function",
    "name": "multiplyFactory",
    "memberof": "src/point/prototype.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/point/prototype.js~multiplyFactory",
    "access": "public",
    "export": true,
    "importPath": "honeycomb-grid/src/point/prototype.js",
    "importStyle": "{multiplyFactory}",
    "description": null,
    "lineNumber": 25,
    "undocument": true,
    "params": [
      {
        "name": "objectPattern",
        "types": [
          "{\"Point\": *}"
        ],
        "defaultRaw": {
          "Point": null
        },
        "defaultValue": "{\"Point\":null}"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 149,
    "kind": "function",
    "name": "divideFactory",
    "memberof": "src/point/prototype.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/point/prototype.js~divideFactory",
    "access": "public",
    "export": true,
    "importPath": "honeycomb-grid/src/point/prototype.js",
    "importStyle": "{divideFactory}",
    "description": null,
    "lineNumber": 37,
    "undocument": true,
    "params": [
      {
        "name": "objectPattern",
        "types": [
          "{\"Point\": *}"
        ],
        "defaultRaw": {
          "Point": null
        },
        "defaultValue": "{\"Point\":null}"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 150,
    "kind": "file",
    "name": "src/point/prototype.spec.js",
    "content": "/* eslint-env mocha */\n\nimport { expect } from 'chai'\n\nimport { ensureXY } from '../utils'\nimport PointFactory from './'\n\nconst Point = PointFactory({ ensureXY })\n\ndescribe('Point methods', function() {\n    describe('add', function() {\n        it('adds the coordinates of the given point to itself', function() {\n            const result = Point(1, -3).add(Point(2, 4))\n            expect(result).to.contain({ x: 3, y: 1 })\n        })\n    })\n\n    describe('subtract', function() {\n        it('subtracts the coordinates of given point from itself', function() {\n            const result = Point(1, -3).subtract(Point(2, 4))\n            expect(result).to.contain({ x: -1, y: -7 })\n        })\n    })\n\n    describe('multiply', function() {\n        it('multiplies the coordinates of given point by itself', function() {\n            const result = Point(1, -3).multiply(Point(2, 4))\n            expect(result).to.contain({ x: 2, y: -12 })\n        })\n    })\n\n    describe('divide', function() {\n        it('divides the coordinates of given point by itself', function() {\n            const result = Point(1, -3).divide(Point(2, 4))\n            expect(result).to.contain({ x: 0.5, y: -0.75 })\n        })\n    })\n})\n",
    "static": true,
    "longname": "/Users/abbe/Projects/honeycomb/src/point/prototype.spec.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 151,
    "kind": "variable",
    "name": "Point",
    "memberof": "src/point/prototype.spec.js",
    "static": true,
    "longname": "src/point/prototype.spec.js~Point",
    "access": "public",
    "export": false,
    "importPath": "honeycomb-grid/src/point/prototype.spec.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 152,
    "kind": "file",
    "name": "src/utils.js",
    "content": "import { isNumber } from 'axis.js'\n\n/**\n * @private\n *\n * @param   {number} offset     The amount to offset (usually -1 or +1).\n * @param   {number} distance   The distance from 0 in a dimension (x, y or q, r).\n *\n * @returns {number}            The amount to offset in the dimension opposite of the passed `distance`.\n */\nexport function offsetFromZero(offset, distance) {\n    return (distance + offset * (distance & 1)) >> 1\n}\n\n/**\n * @private\n *\n * @param   {number} dividend   The amount to get the remainder from after division.\n * @param   {number} divisor    The amount to divide by.\n *\n * @returns {number}            `dividend % divisor`, except negative dividends \"count back from 0\".\n */\nexport function signedModulo(dividend, divisor) {\n    return ((dividend % divisor) + divisor) % divisor\n}\n\n/**\n * @private\n *\n * @param   {string} value              A cardinal/ordinal compass point.\n * @param   {(pointy|flat)} orientation A hex orientation.\n *\n * @returns {(0|1|2|3|4|5)}             The number direction in the range 0..5.\n */\nexport function compassToNumberDirection(value, orientation) {\n    if (!/^(N|S)?(E|W)?$/i.test(value)) {\n        throw new Error(`Invalid compass direction: ${value}. Choose from E, SE, S, SW, W, NW, N or NE.`)\n    }\n\n    orientation = orientation.toLowerCase()\n    value = value.toUpperCase()\n\n    if (orientation === 'pointy' && ['N', 'S'].includes(value)) {\n        throw new Error(`Direction ${value} is ambiguous for pointy hexes. Did you mean ${value}E or ${value}W?`)\n    }\n    if (orientation === 'flat' && ['E', 'W'].includes(value)) {\n        throw new Error(`Direction ${value} is ambiguous for flat hexes. Did you mean N${value} or S${value}?`)\n    }\n\n    /**\n     * There's an (approximate) compass direction for each side of a hex. The right side of a pointy hex has the east (`'E'`) compass direction.\n     * The bottom right side the southeast (`'SE'`) direction, etc. This also means that pointy hexes don't have a north and south compass direction\n     * and flat hexes don't have a west and east compass direction.\n     *\n     * Number directions map to a side of a hex. A pointy hex's right side is `0`, its bottom right side `1`, its bottom left side `2`, etc.\n     * Number directions of flat hexes start at their bottom right side (`0`), their bottom side is `1`, etc.\n     *\n     * @typedef {string} COMPASS_DIRECTION\n     *\n     * @readonly\n     * @enum {COMPASS_DIRECTION}\n     *\n     * @property {COMPASS_DIRECTION} E  → east\n     * @property {COMPASS_DIRECTION} SE ↘ southeast\n     * @property {COMPASS_DIRECTION} S  ↓ south\n     * @property {COMPASS_DIRECTION} SW ↙ southwest\n     * @property {COMPASS_DIRECTION} W  ← west\n     * @property {COMPASS_DIRECTION} NW ↖ northwest\n     * @property {COMPASS_DIRECTION} N  ↑ north\n     * @property {COMPASS_DIRECTION} NE ↗ northeast\n     */\n    return {\n        pointy: { E: 0, SE: 1, SW: 2, W: 3, NW: 4, NE: 5 },\n        flat: { SE: 0, S: 1, SW: 2, NW: 3, N: 4, NE: 5 }\n    }[orientation][value]\n}\n\n/**\n * @private\n */\nexport function ensureXY(x, y) {\n    if (!isNumber(x) && !isNumber(y)) {\n        x = y = 0\n    } else if (!isNumber(x)) {\n        x = y\n    } else if (!isNumber(y)) {\n        y = x\n    }\n\n    return { x, y }\n}\n",
    "static": true,
    "longname": "/Users/abbe/Projects/honeycomb/src/utils.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 153,
    "kind": "function",
    "name": "offsetFromZero",
    "memberof": "src/utils.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils.js~offsetFromZero",
    "access": "private",
    "export": true,
    "importPath": "honeycomb-grid/src/utils.js",
    "importStyle": "{offsetFromZero}",
    "description": "",
    "lineNumber": 11,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number}            The amount to offset in the dimension opposite of the passed `distance`."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "offset",
        "description": "The amount to offset (usually -1 or +1)."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "distance",
        "description": "The distance from 0 in a dimension (x, y or q, r)."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "The amount to offset in the dimension opposite of the passed `distance`."
    },
    "ignore": true
  },
  {
    "__docId__": 154,
    "kind": "function",
    "name": "signedModulo",
    "memberof": "src/utils.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils.js~signedModulo",
    "access": "private",
    "export": true,
    "importPath": "honeycomb-grid/src/utils.js",
    "importStyle": "{signedModulo}",
    "description": "",
    "lineNumber": 23,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number}            `dividend % divisor`, except negative dividends \"count back from 0\"."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "dividend",
        "description": "The amount to get the remainder from after division."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "divisor",
        "description": "The amount to divide by."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "`dividend % divisor`, except negative dividends \"count back from 0\"."
    },
    "ignore": true
  },
  {
    "__docId__": 155,
    "kind": "function",
    "name": "compassToNumberDirection",
    "memberof": "src/utils.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils.js~compassToNumberDirection",
    "access": "private",
    "export": true,
    "importPath": "honeycomb-grid/src/utils.js",
    "importStyle": "{compassToNumberDirection}",
    "description": "",
    "lineNumber": 35,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{(0|1|2|3|4|5)}             The number direction in the range 0..5."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "A cardinal/ordinal compass point."
      },
      {
        "nullable": null,
        "types": [
          "pointy",
          "flat"
        ],
        "spread": false,
        "optional": false,
        "name": "orientation",
        "description": "A hex orientation."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "0",
        "1",
        "2",
        "3",
        "4",
        "5"
      ],
      "spread": false,
      "description": "The number direction in the range 0..5."
    },
    "ignore": true
  },
  {
    "__docId__": 156,
    "kind": "typedef",
    "name": "COMPASS_DIRECTION",
    "memberof": "src/utils.js",
    "static": true,
    "longname": "src/utils.js~COMPASS_DIRECTION",
    "access": "public",
    "description": "There's an (approximate) compass direction for each side of a hex. The right side of a pointy hex has the east (`'E'`) compass direction.\nThe bottom right side the southeast (`'SE'`) direction, etc. This also means that pointy hexes don't have a north and south compass direction\nand flat hexes don't have a west and east compass direction.\n\nNumber directions map to a side of a hex. A pointy hex's right side is `0`, its bottom right side `1`, its bottom left side `2`, etc.\nNumber directions of flat hexes start at their bottom right side (`0`), their bottom side is `1`, etc.",
    "lineNumber": 72,
    "unknown": [
      {
        "tagName": "@readonly",
        "tagValue": ""
      },
      {
        "tagName": "@enum",
        "tagValue": "{COMPASS_DIRECTION}"
      }
    ],
    "properties": [
      {
        "nullable": null,
        "types": [
          "COMPASS_DIRECTION"
        ],
        "spread": false,
        "optional": false,
        "name": "E",
        "description": "→ east"
      },
      {
        "nullable": null,
        "types": [
          "COMPASS_DIRECTION"
        ],
        "spread": false,
        "optional": false,
        "name": "SE",
        "description": "↘ southeast"
      },
      {
        "nullable": null,
        "types": [
          "COMPASS_DIRECTION"
        ],
        "spread": false,
        "optional": false,
        "name": "S",
        "description": "↓ south"
      },
      {
        "nullable": null,
        "types": [
          "COMPASS_DIRECTION"
        ],
        "spread": false,
        "optional": false,
        "name": "SW",
        "description": "↙ southwest"
      },
      {
        "nullable": null,
        "types": [
          "COMPASS_DIRECTION"
        ],
        "spread": false,
        "optional": false,
        "name": "W",
        "description": "← west"
      },
      {
        "nullable": null,
        "types": [
          "COMPASS_DIRECTION"
        ],
        "spread": false,
        "optional": false,
        "name": "NW",
        "description": "↖ northwest"
      },
      {
        "nullable": null,
        "types": [
          "COMPASS_DIRECTION"
        ],
        "spread": false,
        "optional": false,
        "name": "N",
        "description": "↑ north"
      },
      {
        "nullable": null,
        "types": [
          "COMPASS_DIRECTION"
        ],
        "spread": false,
        "optional": false,
        "name": "NE",
        "description": "↗ northeast"
      }
    ],
    "type": {
      "types": [
        "string"
      ],
      "optional": false,
      "name": "COMPASS_DIRECTION"
    }
  },
  {
    "__docId__": 157,
    "kind": "function",
    "name": "ensureXY",
    "memberof": "src/utils.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils.js~ensureXY",
    "access": "private",
    "export": true,
    "importPath": "honeycomb-grid/src/utils.js",
    "importStyle": "{ensureXY}",
    "description": "",
    "lineNumber": 81,
    "ignore": true,
    "params": [
      {
        "name": "x",
        "types": [
          "*"
        ]
      },
      {
        "name": "y",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "{\"x\": *, \"y\": *}"
      ]
    }
  },
  {
    "__docId__": 158,
    "kind": "file",
    "name": "src/utils.spec.js",
    "content": "/* eslint-env mocha */\n\nimport { expect } from 'chai'\n\nimport { compassToNumberDirection, signedModulo } from './utils'\n\ndescribe('signedModulo', () => {\n    describe('when called with a negative dividend', () => {\n        it('returns the modulo mirrored from the divider(?)', () => {\n            expect(signedModulo(1, 6)).to.equal(1)\n            expect(signedModulo(-1, 6)).to.equal(5)\n        })\n    })\n})\n\ndescribe('compassToNumberDirection', () => {\n    let orientation\n\n    describe('when called with an invalid compass direction', () => {\n        it('throws', () => {\n            expect(() => compassToNumberDirection('invalid')).to.throw(\n                'Invalid compass direction: invalid. Choose from E, SE, S, SW, W, NW, N or NE.'\n            )\n        })\n    })\n\n    describe('when called with an ambiguous compass direction', () => {\n        it('throws', () => {\n            expect(() => compassToNumberDirection('N', 'pointy')).to.throw(\n                `Direction N is ambiguous for pointy hexes. Did you mean NE or NW?`\n            )\n            expect(() => compassToNumberDirection('S', 'pointy')).to.throw(\n                `Direction S is ambiguous for pointy hexes. Did you mean SE or SW?`\n            )\n            expect(() => compassToNumberDirection('E', 'flat')).to.throw(\n                `Direction E is ambiguous for flat hexes. Did you mean NE or SE?`\n            )\n            expect(() => compassToNumberDirection('W', 'flat')).to.throw(\n                `Direction W is ambiguous for flat hexes. Did you mean NW or SW?`\n            )\n        })\n    })\n\n    describe('when called with a pointy orientation', () => {\n        before(() => {\n            orientation = 'pointy'\n        })\n\n        it('converts a compass direction to a number direction', () => {\n            expect(compassToNumberDirection('E', orientation)).to.equal(0)\n            expect(compassToNumberDirection('SE', orientation)).to.equal(1)\n            expect(compassToNumberDirection('SW', orientation)).to.equal(2)\n            expect(compassToNumberDirection('W', orientation)).to.equal(3)\n            expect(compassToNumberDirection('NW', orientation)).to.equal(4)\n            expect(compassToNumberDirection('NE', orientation)).to.equal(5)\n        })\n    })\n\n    describe('when called with a flat orientation', () => {\n        before(() => {\n            orientation = 'flat'\n        })\n\n        it('converts a compass direction to a number direction', () => {\n            expect(compassToNumberDirection('SE', orientation)).to.equal(0)\n            expect(compassToNumberDirection('S', orientation)).to.equal(1)\n            expect(compassToNumberDirection('SW', orientation)).to.equal(2)\n            expect(compassToNumberDirection('NW', orientation)).to.equal(3)\n            expect(compassToNumberDirection('N', orientation)).to.equal(4)\n            expect(compassToNumberDirection('NE', orientation)).to.equal(5)\n        })\n    })\n})\n",
    "static": true,
    "longname": "/Users/abbe/Projects/honeycomb/src/utils.spec.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "kind": "index",
    "content": "# Honeycomb\n\n[![Gitter](https://img.shields.io/gitter/room/flauwekeul/honeycomb.svg)](https://gitter.im/honeycomb-grid)\n[![NPM version](https://badge.fury.io/js/honeycomb-grid.svg)](https://www.npmjs.com/package/honeycomb-grid)\n[![dependencies](https://david-dm.org/flauwekeul/honeycomb.svg)](https://david-dm.org/flauwekeul/honeycomb)\n[![devDependencies](https://david-dm.org/flauwekeul/honeycomb/dev-status.svg)](https://david-dm.org/flauwekeul/honeycomb?type=dev)\n[![GitHub license](https://img.shields.io/badge/license-MIT-blue.svg)](https://github.com/flauwekeul/honeycomb/blob/master/LICENSE)\n\nAnother hex grid library made in JavaScript, heavily inspired by [Red Blob Games'](http://www.redblobgames.com/grids/hexagons/) blog posts and code samples.\n\nAll existing JS hex grid libraries I could find are coupled with some form of view. Most often a `<canvas>` element or the browser DOM. I want more separation of concerns...and a new hobby project to spend countless hours on.\n\n### Features\n\n-   🙌 Works in (modern) browsers and in Node.js.\n-   📐 Create hex grids in different shapes: ▭ rectangles, △ triangles, ⬡ hexagons and ▱ parallelograms.\n-   🌐 2 coordinate systems: cartesian (`x` and `y`) and cube (`q`, `r` and `s`).\n-   ✨ Create your own hexes by extending the built-in Hex.\n-   🗺 Convert points to hexes and vice versa.\n-   ⬢ Pointy and ⬣ flat hexes.\n-   🖥 Lets you decide if and how hexes are rendered.\n\n## Installation\n\nNPM:\n\n```bash\nnpm i --save honeycomb-grid\n```\n\nYarn:\n\n```bash\nyarn add honeycomb-grid\n```\n\n## Getting started\n\n### Browser\n\n```html\n<script src=\"honeycomb.js\"></script>\n\n<script>\n    const Grid = Honeycomb.defineGrid()\n    Grid.rectangle({ width: 4, height: 4 })\n</script>\n```\n\n### Node.js\n\n```javascript\nconst Honeycomb = require('honeycomb-grid')\n\nconst Grid = Honeycomb.defineGrid()\nGrid.rectangle({ width: 4, height: 4 })\n```\n\n## Examples\n\n### Basic usage\n\nCreate a hex grid in 3 steps:\n\n```javascript\n// 1.  (optionally) create a Hex factory by extending the default:\nconst Hex = Honeycomb.extendHex({\n    size: 30,           // default: 1\n    orientation: 'flat' // default: 'pointy'\n})\n\n// 2.  create a Grid factory that uses the Hex factory:\nconst Grid = Honeycomb.defineGrid(Hex)\n\n// 3a. create a grid with a \"shape\" method:\nconst grid1 = Grid.rectangle({ width: 4, height: 4 })\n// [\n//    { x: 0, y: 0 },\n//    { x: 0, y: 1 },\n//    { x: 0, y: 2 },\n//    …\n// ]\n\n// 3b. or create a grid from individual hexes:\nconst grid2 = Grid(Hex(1, 2), Hex(3, 4))\n// [\n//    { x: 1, y: 2 },\n//    { x: 3, y: 4 }\n// ]\n```\n\n### Rendering\n\nHoneycomb comes without the ability to render hexes to screen. Fortunately, it isn't very hard. Especially if you use a dedicated rendering library.\n\n#### With [PixiJS](http://www.pixijs.com/)\n\n```javascript\nconst app = new PIXI.Application({ transparent: true })\nconst graphics = new PIXI.Graphics()\n\nconst Hex = Honeycomb.extendHex({ size: 5 })\nconst Grid = Honeycomb.defineGrid(Hex)\n\ndocument.body.appendChild(app.view)\n// set a line style of 1px wide and color #999\ngraphics.lineStyle(1, 0x999999)\n\n// render 10,000 hexes\nGrid.rectangle({ width: 100, height: 100 }).forEach(hex => {\n    const point = hex.toPoint()\n    // add the hex's position to each of its corner points\n    const corners = hex.corners().map(corner => corner.add(point))\n    // separate the first from the other corners\n    const [firstCorner, ...otherCorners] = corners\n\n    // move the \"pen\" to the first corner\n    graphics.moveTo(firstCorner.x, firstCorner.y)\n    // draw lines to the other corners\n    otherCorners.forEach(({ x, y }) => graphics.lineTo(x, y))\n    // finish at the first corner\n    graphics.lineTo(firstCorner.x, firstCorner.y)\n\n    app.stage.addChild(graphics)\n})\n```\n\n[Try it in JSFiddle](https://jsfiddle.net/Flauwekeul/qmfgey44/).\n\n#### With [SVG.js](http://svgjs.com/)\n\n```javascript\nconst draw = SVG(document.body)\n\nconst Hex = Honeycomb.extendHex({ size: 5 })\nconst Grid = Honeycomb.defineGrid(Hex)\n// get the corners of a hex (they're the same for all hexes created with the same Hex factory)\nconst corners = Hex().corners()\n// an SVG symbol can be reused\nconst hexSymbol = draw.symbol()\n    // map the corners' positions to a string and create a polygon\n    .polygon(corners.map(({ x, y }) => `${x},${y}`))\n    .fill('none')\n    .stroke({ width: 1, color: '#999' })\n\n// render 10,000 hexes\nGrid.rectangle({ width: 100, height: 100 }).forEach(hex => {\n    const { x, y } = hex.toPoint()\n    // use hexSymbol and set its position for each hex\n    draw.use(hexSymbol).translate(x, y)\n})\n```\n\n[Try it in JSFiddle](https://jsfiddle.net/Flauwekeul/0vm2azj2/).\n\n### Grids extend `Array.prototype`\n\nMost properties/methods of grids are the same as their Array counterpart:\n\n```javascript\nconst grid = Grid.rectangle({ width: 4, height: 4 })\n\ngrid.length // 16\ngrid.pop()  // { x: 3, y: 3 }\ngrid.length // 15\ngrid[4]     // { x: 1, y: 0 }\n```\n\nSome Grid methods are augmented. For example: [`Array#includes`](https://developer.mozilla.org/nl/docs/Web/JavaScript/Reference/Global_Objects/Array/includes) always returns `false` when passed an object literal because it uses [strict equality](https://developer.mozilla.org/nl/docs/Web/JavaScript/Equality_comparisons_and_sameness) internally. [`Grid#includes`](#includes) _only_ accepts object literals (in the form of [points](#point-1)):\n\n```javascript\nconst array = [{ x: 1, y: 0 }]\narray.includes({ x: 1, y: 0 })  // false\n\nconst grid = Grid(Hex(1, 0))\ngrid.includes({ x: 1, y: 0 })   // true\n```\n\n#### Grid methods that mutate\n\nMethods that mutate the grid in-place ([Grid#push](#push), [Grid#splice](#splice) and [Grid#unshift](#unshift)) only accept valid hexes to prevent \"grid corruption\" 👮‍.\n\n```javascript\nconst grid = Grid()             // []\n\n// this silently fails:\ngrid.push('invalid hex')        // 0 <- the grid's length, which remains 0\ngrid.includes('invalid hex')    // false\n```\n\nKeep in mind that methods that return a new grid (e.g. [Grid#map](#map)) can create grids with invalid hexes:\n\n```javascript\nconst grid = Grid.rectangle({ width: 4, height: 4 })\n\nconst newGrid = grid.map(hex => 'invalid hex')\n// [\n//    'invalid hex',\n//    'invalid hex',\n//    'invalid hex',\n//    …\n// ]\n```\n\n#### Be careful with bracket notation\n\nIt's possible to add an invalid hex to a grid by using bracket notation:\n\n```javascript\nconst grid = Grid(Hex())\n\ngrid[0]                     // { x: 0, y: 0 }\ngrid[0] = 'invalid hex'\ngrid[0]                     // 'invalid hex' ⚠️\n```\n\nUse [`Grid#get`](#get) and [`Grid#set`](#set) instead:\n\n```javascript\nconst grid = Grid(Hex())\n\ngrid.get(0)                 // { x: 0, y: 0 }\ngrid.set(0, 'invalid hex')\ngrid.get(0)                 // { x: 0, y: 0 } <- invalid hex is ignored\n\n// Grid#set() also accepts a point:\ngrid.set({ x: 0, y: 0 }, Hex(-1, 3))\n// …as does Grid#get():\ngrid.get([-1, 3])           // { x: -1, y: 3 }\n```\n\n### Point → Hex\n\nTranslating a point (pixel) in the grid to the corresponding hex is possible with [`Grid.pointToHex()`](#pointtohex).\n\n```javascript\nconst Hex = Honeycomb.extendHex({ size: 30 })\nconst Grid = Honeycomb.defineGrid(Hex)\nconst grid = Grid.rectangle({ width: 10, height: 10 })\n\ndocument.addEventListener('click', ({ offsetX, offsetY }) => {\n    // convert point to hex (coordinates)\n    const hexCoordinates = Grid.pointToHex([offsetX, offsetY])\n    // get the actual hex from the grid\n    console.log(grid.get(hexCoordinates))\n})\n```\n\nSee a more elaborate example in [JSFiddle](https://jsfiddle.net/Flauwekeul/3bd6sa9r/).\n\n### Grid shapes\n\nHoneycomb offers 4 shape methods: [rectangle](#rectangle), [triangle](#triangle), [hexagon](#hexagon) and [parallelogram](#parallelogram). [Try them out in JSFiddle](https://jsfiddle.net/Flauwekeul/arxo1vqo/).\n\n### Coordinate systems\n\nThe standard coordinate system is a [cartesian](https://en.wikipedia.org/wiki/Cartesian_coordinate_system) one. It's intuitive and easy to reason about. A lot of methods internally use a \"cube\" coordinate system. See [this redblobgames.com blog post](https://www.redblobgames.com/grids/hexagons/#coordinates) for an explanation between the two (he calls the cartesian system \"offset coordinates\").\n\nHexes have getters for each of the cube coordinates `q`, `r` and `s`:\n\n```javascript\nconst Hex = Honeycomb.extendHex()\nconst hex = Hex(3, 4)\n\nhex.q           // 1\nhex.r           // 4\nhex.s           // -5\n\nhex.cartesian() // { x: 3, y: 4 }\nhex.cube()      // { q: 1, r: 4, s: -5 }\n```\n\nThere are methods for converting between cartesian and cube:\n\n```javascript\nconst Hex = Honeycomb.extendHex()\nconst hex = Hex()\n\nhex.toCube({ x: 3, y: 4 })      // { q: 1, r: 4, s: -5 }\n\n// Hex#toCartesian doesn't require the s coordinate:\nhex.toCartesian({ q: 1, r: 4 }) // { x: 3, y: 4 }\n```\n\n> These methods always require coordinates to be passed and don't work on a hex instance, even though they're instance methods. This will be fixed in a future release 🙃\n\nHexes can also be created from cube coordinates:\n\n```javascript\nconst Hex = Honeycomb.extendHex()\nHex({ q: 1, r: 4, s: -5 })  // { x: 3, y: 4 }\n```\n## Backlog\n\n### 🐛 Bugs\n\n### 🚀 Features\n\n3.  Hex methods that do nothing with a hex's coordinates should be static (e.g. `cubeToCartesian`, `isPointy`, `width`)?\n4.  Make some Grid instance methods also Grid static methods and vice versa?\n5.  Make more methods accept points (instead of hexes). Also: instead of filtering invalid hexes, attempt to convert values to hexes (by passing them to `Hex()`)?\n6.  Make some methods getters (e.g. `Hex#width`)?\n7.  Make methods that accept points, also accept `x` and `y` as separate parameters?\n8.  Maybe make entities immutable?\n9.  Add possibility to [stretch hexes](http://www.redblobgames.com/grids/hexagons/implementation.html#layout-test-size-tall); they needn't be regularly shaped. This is an [actual request](https://github.com/flauwekeul/honeycomb/issues/1) as well. Maybe this should be solved during rendering (and not in Honeycomb at all)?\n10. Add logger that \"renders\" a grid using `console.log`.\n11. Overwrite `Grid#sort` so it can sort by 1 or more dimensions, ascending/descending (and also accepts a custom comparator)?\n12. Add `Grid.union`, `Grid.subtract`, `Grid.intersect` and `Grid.difference` (or maybe as prototype methods?). [More info](https://www.sketchapp.com/docs/shapes/boolean-operations/).\n13. Shiny github.io pages 😎\n14. Maybe `Honeycomb.defineGrid` should accept a prototype too (as a second parameter).\n15. Maybe `Honeycomb` should (also) be a function that accepts a hex prototype and returns a Grid factory?\n16. Investigate how instance properties are set vs prototype properties. When creating a custom hex it should be possible to set properties that are copied when creating new hexes and properties that only exist in the prototype. Similar to how [stampit](https://github.com/stampit-org/stampit) solves this.\n17. Add type definition files? Potential tools: [dts-gen](https://github.com/Microsoft/dts-gen), [dtsmake](https://github.com/ConquestArrow/dtsmake).\n\n### 🛠 Refactorings\n\n1.  Only inject what's needed, instead of whole factories (see `Grid.rectangle()` for example).\n2.  Don't use `this` at all and just inject a context. Functional programming yo 🤓.\n",
    "longname": "/Users/abbe/Projects/honeycomb/README.md",
    "name": "./README.md",
    "static": true,
    "access": "public"
  },
  {
    "kind": "packageJSON",
    "content": "{\n  \"name\": \"honeycomb-grid\",\n  \"version\": \"1.1.1\",\n  \"description\": \"Create hexagon grids easily. Written in javascript.\",\n  \"source\": \"src/honeycomb.js\",\n  \"main\": \"dist/honeycomb.min.js\",\n  \"scripts\": {\n    \"build\": \"rollup --config rollup.config.js\",\n    \"coverage\": \"NODE_ENV=test nyc --reporter html --exclude \\\"**/*.spec.js\\\" npm test\",\n    \"dev\": \"npm run build -- --watch\",\n    \"docs\": \"esdoc\",\n    \"lint\": \"eslint src --fix\",\n    \"precommit\": \"npm run lint\",\n    \"prerelease\": \"npm run lint; npm test; npm run docs; NODE_ENV=production npm run build\",\n    \"release\": \"git add --patch; standard-version --commit-all\",\n    \"start\": \"npm run build && node --require ./dist/honeycomb.js\",\n    \"test\": \"NODE_ENV=test nyc mocha --require ./test/config.js ./src --recursive\",\n    \"test:watch\": \"npm test -- --watch --bail\"\n  },\n  \"author\": \"Abbe Keultjes <flauwekeul@gmail.com>\",\n  \"license\": \"MIT\",\n  \"devDependencies\": {\n    \"babel-core\": \"6.26.0\",\n    \"babel-plugin-external-helpers\": \"6.22.0\",\n    \"babel-plugin-istanbul\": \"4.1.5\",\n    \"babel-plugin-transform-object-rest-spread\": \"6.26.0\",\n    \"babel-preset-env\": \"1.6.1\",\n    \"chai\": \"4.1.2\",\n    \"cz-conventional-changelog\": \"2.1.0\",\n    \"esdoc\": \"1.0.4\",\n    \"esdoc-ecmascript-proposal-plugin\": \"1.0.0\",\n    \"esdoc-standard-plugin\": \"1.0.0\",\n    \"eslint\": \"4.18.0\",\n    \"husky\": \"0.14.3\",\n    \"istanbul\": \"0.4.5\",\n    \"mocha\": \"5.0.1\",\n    \"nyc\": \"11.4.1\",\n    \"rollup\": \"0.56.1\",\n    \"rollup-plugin-babel\": \"3.0.3\",\n    \"rollup-plugin-commonjs\": \"8.3.0\",\n    \"rollup-plugin-node-resolve\": \"3.0.3\",\n    \"rollup-plugin-uglify\": \"3.0.0\",\n    \"sinon\": \"4.3.0\",\n    \"sinon-chai\": \"2.14.0\",\n    \"standard-version\": \"4.3.0\"\n  },\n  \"directories\": {\n    \"test\": \"test\"\n  },\n  \"dependencies\": {\n    \"axis.js\": \"1.2.1\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/flauwekeul/honeycomb.git\"\n  },\n  \"keywords\": [\n    \"es2015\",\n    \"grid\",\n    \"hex\",\n    \"hex-grid\",\n    \"hexagon\",\n    \"node\"\n  ],\n  \"bugs\": {\n    \"url\": \"https://github.com/flauwekeul/honeycomb/issues\"\n  },\n  \"homepage\": \"http://abbekeultjes.nl/honeycomb\",\n  \"nyc\": {\n    \"require\": [\n      \"babel-register\"\n    ],\n    \"sourceMap\": false,\n    \"instrument\": false\n  },\n  \"config\": {\n    \"commitizen\": {\n      \"path\": \"cz-conventional-changelog\"\n    }\n  }\n}\n",
    "longname": "/Users/abbe/Projects/honeycomb/package.json",
    "name": "package.json",
    "static": true,
    "access": "public"
  }
]