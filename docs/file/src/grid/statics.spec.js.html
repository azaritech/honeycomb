<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../">
  <title data-ice="title">src/grid/statics.spec.js | honeycomb-grid</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="Create hexagon grids easily. Written in javascript."><meta property="twitter:card" content="summary"><meta property="twitter:title" content="honeycomb-grid"><meta property="twitter:description" content="Create hexagon grids easily. Written in javascript."></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/flauwekeul/honeycomb"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-COMPASS_DIRECTION">COMPASS_DIRECTION</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#grid">grid</a><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-get">get</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-hexesBetween">hexesBetween</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-setFactory">setFactory</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-grid">grid</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#hex">hex</a><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-extendHexFactory">extendHexFactory</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-cartesianToCube">cartesianToCube</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-coordinates">coordinates</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-cube">cube</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-cubeToCartesian">cubeToCartesian</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-distance">distance</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-equalsFactory">equalsFactory</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-height">height</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-isFlat">isFlat</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-isPointy">isPointy</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-nudge">nudge</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-oppositeCornerDistance">oppositeCornerDistance</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-oppositeSideDistance">oppositeSideDistance</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-toString">toString</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-width">width</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-thirdCoordinate">thirdCoordinate</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-DIAGONAL_DIRECTION_COORDINATES">DIAGONAL_DIRECTION_COORDINATES</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-DIRECTION_COORDINATES">DIRECTION_COORDINATES</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-EPSILON">EPSILON</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-OFFSET">OFFSET</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-ORIENTATION">ORIENTATION</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-staticMethods">staticMethods</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-hex">hex</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#point">point</a><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-PointFactory">PointFactory</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-addFactory">addFactory</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-divideFactory">divideFactory</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-multiplyFactory">multiplyFactory</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-subtractFactory">subtractFactory</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-point">point</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/grid/statics.spec.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">/* eslint-env mocha */

import { expect } from &apos;chai&apos;
import sinon from &apos;sinon&apos;

import { ensureXY, compassToNumberDirection, signedModulo } from &apos;../utils&apos;
import extendHexFactory from &apos;../hex&apos;
import Grid from &apos;./class&apos;
import * as statics from &apos;./statics&apos;

const extendHex = extendHexFactory({ ensureXY })
const Hex = extendHex()

describe(&apos;isValidHex&apos;, () =&gt; {
    it(&apos;calls Grid.isValidHex&apos;, () =&gt; {
        sinon.spy(Grid, &apos;isValidHex&apos;)

        const isValidHex = statics.isValidHexFactory({ Grid })
        isValidHex(&apos;value&apos;)

        expect(Grid.isValidHex).to.have.been.calledWith(&apos;value&apos;)

        Grid.isValidHex.restore()
    })
})

describe(&apos;pointToHex&apos;, function() {
    let subtract, Point, isPointy, hexResult, Hex, round, center, pointToHex, point

    beforeEach(function() {
        point = { x: 1, y: 1 }
        subtract = sinon.stub().returns(point)
        Point = sinon.stub().returns({ subtract })
        isPointy = sinon.stub()
        round = sinon.stub().returns(&apos;round result&apos;)
        center = sinon.stub().returns(&apos;center result&apos;)
        hexResult = {
            size: 1,
            isPointy,
            round,
            center
        }
        Hex = sinon.stub().returns(hexResult)
        pointToHex = statics.pointToHexFactory({ Point, Hex })
    })

    it(&apos;calls Hex to access its size, center and isPointy&apos;, function() {
        pointToHex(point)
        expect(Hex).to.have.been.called
    })

    it(&apos;calls Point with the passed point to convert it to an actual point&apos;, function() {
        pointToHex(point)
        expect(Point).to.have.been.calledWith(point)
    })

    it(`subtracts the hex&apos;s center from the point`, function() {
        pointToHex(point)
        expect(center).to.have.been.called
        expect(subtract).to.have.been.calledWith(&apos;center result&apos;)
    })

    describe(&apos;when the hex has a pointy orientation&apos;, function() {
        beforeEach(function() {
            isPointy.returns(true)
        })

        it(&apos;creates a new hex&apos;, function() {
            pointToHex(point)
            expect(Hex.secondCall.args[0].q).to.be.closeTo(0.2440, 0.0005)
            expect(Hex.secondCall.args[0].r).to.be.closeTo(0.6667, 0.0005)
        })
    })

    describe(&apos;when the hex has a flat orientation&apos;, function() {
        beforeEach(function() {
            isPointy.returns(false)
        })

        it(&apos;creates a new hex&apos;, function() {
            pointToHex(point)
            expect(Hex.secondCall.args[0].q).to.be.closeTo(0.6667, 0.0005)
            expect(Hex.secondCall.args[0].r).to.be.closeTo(0.2440, 0.0005)
        })
    })

    it(&apos;rounds that hex&apos;, function() {
        pointToHex(point)
        expect(round).to.have.been.called
    })

    it(&apos;returns the hex&apos;, function() {
        const result = pointToHex(point)
        expect(result).to.equal(&apos;round result&apos;)
    })
})

describe(&apos;parallelogram&apos;, function() {
    let parallelogram

    before(function() {
        parallelogram = statics.parallelogramFactory({ Grid, Hex })
    })

    it(&apos;returns a grid instance with a length of (width &#x2A09; height) hexes&apos;, function() {
        const gridInstance = sinon.createStubInstance(Grid)
        const GridSpy = sinon.spy(() =&gt; gridInstance)
        const parallelogram = statics.parallelogramFactory({ Grid: GridSpy, Hex })
        const result = parallelogram({ width: 2, height: 3 })

        expect(result).to.equal(gridInstance)
        expect(gridInstance.push.callCount).to.equal(6)
    })

    describe(&apos;when called without start hex or direction&apos;, function() {
        it(&apos;returns the hexes in a parallelogram shape, starting at Hex(0)&apos;, function() {
            expect(parallelogram({ width: 2, height: 2 })).to.contain.hexes([
                { x: 0, y: 0 },
                { x: 1, y: 0 },
                { x: 0, y: 1 },
                { x: 1, y: 1 }
            ])
        })
    })

    describe(&apos;when called with start hex&apos;, function() {
        it(&apos;returns the hexes in a parallelogram shape, starting at the given start hex&apos;, function() {
            expect(parallelogram({
                width: 2,
                height: 2,
                start: Hex(5, 4)
            })).to.contain.hexes([
                { x: 5, y: 4 },
                { x: 6, y: 4 },
                { x: 5, y: 5 },
                { x: 6, y: 5 }
            ])
        })
    })

    describe(&apos;when called with direction 1&apos;, function() {
        it(&apos;returns the hexes in a parallelogram shape, in a southeastern direction&apos;, function() {
            expect(parallelogram({
                width: 2,
                height: 2,
                direction: 1
            })).to.contain.hexes([
                { x: 0, y: 0 },
                { x: 1, y: 0 },
                { x: 0, y: 1 },
                { x: 1, y: 1 }
            ])
        })
    })

    describe(&apos;when called with direction 3&apos;, function() {
        it(&apos;returns the hexes in a parallelogram shape, in a southwestern direction&apos;, function() {
            expect(parallelogram({
                width: 2,
                height: 2,
                direction: 3
            })).to.contain.hexes([
                { x: -1, y: 0 },
                { x: 0, y: 0 },
                { x: -2, y: 1 },
                { x: -1, y: 1 }
            ])
        })
    })

    describe(&apos;when called with direction 5&apos;, function() {
        it(&apos;returns the hexes in a parallelogram shape, in a northern direction&apos;, function() {
            expect(parallelogram({
                width: 2,
                height: 2,
                direction: 5
            })).to.contain.hexes([
                { x: 0, y: -2 },
                { x: -1, y: -1 },
                { x: 0, y: -1 },
                { x: 0, y: 0 }
            ])
        })
    })

    describe(&apos;when called with an onCreate callback&apos;, function() {
        it(&apos;calls the callback for each created hex passing the hex and the grid&apos;, function() {
            const callback = sinon.spy()
            const result = parallelogram({
                width: 2,
                height: 2,
                onCreate: callback
            })
            expect(callback.callCount).to.eql(4)
            expect(callback).to.always.have.been.calledWithExactly(
                sinon.match.has(&apos;__isHoneycombHex&apos;, true),
                sinon.match.same(result)
            )
        })
    })
})

describe(&apos;triangle&apos;, function() {
    let triangle

    before(function() {
        triangle = statics.triangleFactory({ Grid, Hex })
    })

    // https://en.wikipedia.org/wiki/Triangular_number
    it(&apos;returns a grid instance with a length of the triangular number of the size&apos;, function() {
        const gridInstance = sinon.createStubInstance(Grid)
        const GridSpy = sinon.spy(() =&gt; gridInstance)
        const triangle = statics.triangleFactory({ Grid: GridSpy, Hex })
        const result = triangle({ size: 4 })

        expect(result).to.equal(gridInstance)
        expect(gridInstance.push.callCount).to.equal(4 + 3 + 2 + 1)
    })

    describe(&apos;when called without start hex or direction&apos;, function() {
        it(&apos;returns the hexes in a triangle shape, starting at Hex(0)&apos;, function() {
            expect(triangle({ size: 2 })).to.contain.hexes([
                { x: 0, y: 0 },
                { x: 1, y: 0 },
                { x: 0, y: 1 }
            ])
        })
    })

    describe(&apos;when called with start hex&apos;, function() {
        it(&apos;returns the hexes in a triangle shape, starting at the given start hex&apos;, function() {
            expect(triangle({
                size: 2,
                start: Hex(3, 6)
            })).to.contain.hexes([
                { x: 3, y: 6 },
                { x: 4, y: 6 },
                { x: 3, y: 7 }
            ])
        })
    })

    describe(&apos;when called with direction 1&apos;, function() {
        it(&apos;returns the hexes in a triangle shape, pointing down&apos;, function() {
            expect(triangle({
                size: 2,
                direction: 1
            })).to.contain.hexes([
                { x: 0, y: 0 },
                { x: 1, y: 0 },
                { x: 0, y: 1 }
            ])
        })
    })

    describe(&apos;when called with direction 5&apos;, function() {
        it(&apos;returns the hexes in a triangle shape, pointing up&apos;, function() {
            expect(triangle({
                size: 2,
                direction: 5
            })).to.contain.hexes([
                { x: 1, y: 1 },
                { x: 1, y: 2 },
                { x: 2, y: 2 }
            ])
        })
    })

    describe(&apos;when called with an onCreate callback&apos;, function() {
        it(&apos;calls the callback for each created hex passing the hex and the grid&apos;, function() {
            const callback = sinon.spy()
            const result = triangle({
                size: 2,
                onCreate: callback
            })
            expect(callback.callCount).to.eql(3)
            expect(callback).to.always.have.been.calledWithExactly(
                sinon.match.has(&apos;__isHoneycombHex&apos;, true),
                sinon.match.same(result)
            )
        })
    })
})

describe(&apos;hexagon&apos;, function() {
    let hexagon

    before(function() {
        hexagon = statics.hexagonFactory({ Grid, Hex })
    })

    it(&apos;returns a grid instance with a hard to determine amount of hexes &#x1F62C;&apos;, function() {
        const gridInstance = sinon.createStubInstance(Grid)
        const GridSpy = sinon.spy(() =&gt; gridInstance)
        const hexagon = statics.hexagonFactory({ Grid: GridSpy, Hex })
        const result = hexagon({ radius: 3 })

        expect(result).to.equal(gridInstance)
        expect(gridInstance.push.callCount).to.equal(37)
    })

    describe(&apos;when called without center hex&apos;, function() {
        it(&apos;returns the hexes in a hexagon shape, with its center at Hex(0)&apos;, function() {
            expect(hexagon({ radius: 1 })).to.contain.hexes([
                { x: -1, y: 1 },
                { x: 0, y: -1 },
                { x: -1, y: 0 },
                { x: 0, y: 0 },
                { x: 1, y: 0 },
                { x: -1, y: 1 },
                { x: 0, y: 1 }
            ])
        })
    })

    describe(&apos;when called with center hex&apos;, function() {
        it(&apos;returns the hexes in a hexagon shape, with its center at the given center hex&apos;, function() {
            expect(hexagon({
                radius: 1,
                center: Hex(3, 1)
            })).to.contain.hexes([
                { x: 3, y: 0 },
                { x: 4, y: 0 },
                { x: 2, y: 1 },
                { x: 3, y: 1 },
                { x: 4, y: 1 },
                { x: 3, y: 2 },
                { x: 4, y: 2 }
            ])
        })
    })

    describe(&apos;when called with an onCreate callback&apos;, function() {
        it(&apos;calls the callback for each created hex passing the hex and the grid&apos;, function() {
            const callback = sinon.spy()
            const result = hexagon({
                radius: 1,
                onCreate: callback
            })
            expect(callback.callCount).to.eql(7)
            expect(callback).to.always.have.been.calledWithExactly(
                sinon.match.has(&apos;__isHoneycombHex&apos;, true),
                sinon.match.same(result)
            )
        })
    })
})

describe(&apos;rectangle&apos;, function() {
    let compassToNumberDirectionSpy, signedModuloSpy, Hex, rectangle

    before(function() {
        compassToNumberDirectionSpy = sinon.spy(compassToNumberDirection)
        signedModuloSpy = sinon.spy(signedModulo)
        Hex = extendHex()
        rectangle = statics.rectangleFactory({
            Grid,
            Hex,
            compassToNumberDirection: compassToNumberDirectionSpy,
            signedModulo: signedModuloSpy
        })
    })

    it(&apos;returns a grid instance with a length of (width &#x2A09; height) hexes&apos;, function() {
        const gridInstance = sinon.createStubInstance(Grid)
        const GridSpy = sinon.spy(() =&gt; gridInstance)
        const rectangle = statics.rectangleFactory({ Grid: GridSpy, Hex })
        const result = rectangle({ width: 4, height: 5 })

        expect(result).to.equal(gridInstance)
        expect(gridInstance.push.callCount).to.equal(20)
    })

    describe(&apos;when called with a compass direction&apos;, () =&gt; {
        it(&apos;calls compassToNumberDirection&apos;, () =&gt; {
            rectangle({ direction: &apos;E&apos; })
            expect(compassToNumberDirectionSpy).to.have.been.calledWith(&apos;E&apos;, &apos;pointy&apos;)
        })
    })

    describe(&apos;when called with directions outside 0..5&apos;, () =&gt; {
        it(`passes them to signedModulo`, () =&gt; {
            rectangle({ direction: -1 })
            expect(signedModuloSpy).to.have.been.calledWith(-1, 6)

            signedModuloSpy.reset()

            rectangle({ direction: 3 })
            expect(signedModuloSpy).not.to.have.been.called
        })
    })

    describe(&apos;when hexes have a pointy orientation&apos;, function() {
        before(function() {
            Hex = extendHex({ orientation: &apos;pointy&apos; })
            rectangle = statics.rectangleFactory({ Grid, Hex })
        })

        describe(&apos;when called without start hex or direction&apos;, function() {
            it(&apos;returns the hexes in a rectangle shape in direction 0, starting at Hex(0)&apos;, function() {
                expect(rectangle({ width: 2, height: 3 })).to.contain.hexes([
                    { x: 0, y: 0 },
                    { x: 1, y: 0 },
                    { x: 0, y: 1 },
                    { x: 1, y: 1 },
                    { x: 0, y: 2 },
                    { x: 1, y: 2 }
                ])
            })
        })

        describe(&apos;when called with start hex&apos;, function() {
            it(&apos;returns the hexes in a rectangle shape, starting at the given start hex&apos;, function() {
                expect(rectangle({
                    width: 2,
                    height: 3,
                    start: Hex(-4, -2)
                })).to.contain.hexes([
                    { x: -4, y: -2 },
                    { x: -3, y: -2 },
                    { x: -4, y: -1 },
                    { x: -3, y: -1 },
                    { x: -4, y: 0 },
                    { x: -3, y: 0 }
                ])
            })
        })

        describe(&apos;when called with direction 0&apos;, function() {
            it(&apos;returns the hexes in a rectangle shape, in an eastern direction&apos;, function() {
                expect(rectangle({
                    width: 2,
                    height: 2,
                    direction: 0
                })).to.contain.hexes([
                    { x: 0, y: 0 },
                    { x: 1, y: 0 },
                    { x: 0, y: 1 },
                    { x: 1, y: 1 }
                ])
            })
        })

        describe(&apos;when called with direction 1&apos;, function() {
            it(&apos;returns the hexes in a rectangle shape, in a southeastern direction&apos;, function() {
                expect(rectangle({
                    width: 2,
                    height: 2,
                    direction: 1
                })).to.contain.hexes([
                    { x: 0, y: 0 },
                    { x: 0, y: 1 },
                    { x: 1, y: 0 },
                    { x: 1, y: 1 }
                ])
            })
        })

        describe(&apos;when called with direction 2&apos;, function() {
            it(&apos;returns the hexes in a rectangle shape, in a southwestern direction&apos;, function() {
                expect(rectangle({
                    width: 2,
                    height: 2,
                    direction: 2
                })).to.contain.hexes([
                    { x: 0, y: 0 },
                    { x: -1, y: 1 },
                    { x: -1, y: 0 },
                    { x: -2, y: 1 }
                ])
            })
        })

        describe(&apos;when called with direction 3&apos;, function() {
            it(&apos;returns the hexes in a rectangle shape, in a western direction&apos;, function() {
                expect(rectangle({
                    width: 2,
                    height: 2,
                    direction: 3
                })).to.contain.hexes([
                    { x: 0, y: 0 },
                    { x: -1, y: 0 },
                    { x: -1, y: 1 },
                    { x: -2, y: 1 }
                ])
            })
        })

        describe(&apos;when called with direction 4&apos;, function() {
            it(&apos;returns the hexes in a rectangle shape, in a northwestern direction&apos;, function() {
                expect(rectangle({
                    width: 2,
                    height: 2,
                    direction: 4
                })).to.contain.hexes([
                    { x: 0, y: -2 },
                    { x: -1, y: -1 },
                    { x: 0, y: -1 },
                    { x: 0, y: 0 }
                ])
            })
        })

        describe(&apos;when called with direction 5&apos;, function() {
            it(&apos;returns the hexes in a rectangle shape, in a northeastern direction&apos;, function() {
                expect(rectangle({
                    width: 2,
                    height: 2,
                    direction: 5
                })).to.contain.hexes([
                    { x: 0, y: -2 },
                    { x: -1, y: -1 },
                    { x: 0, y: -1 },
                    { x: 0, y: 0 }
                ])
            })
        })
    })

    describe(&apos;when hexes have a flat orientation&apos;, function() {
        before(function() {
            Hex = extendHex({ orientation: &apos;flat&apos; })
            rectangle = statics.rectangleFactory({ Grid, Hex })
        })

        describe(&apos;when called without start hex or direction&apos;, function() {
            it(&apos;returns the hexes in a rectangle shape in direction 1, starting at Hex(0)&apos;, function() {
                expect(rectangle({ width: 2, height: 3 })).to.contain.hexes([
                    { x: 0, y: 0 },
                    { x: 1, y: 0 },
                    { x: 0, y: 1 },
                    { x: 1, y: 1 },
                    { x: 0, y: 2 },
                    { x: 1, y: 2 }
                ])
            })
        })

        describe(&apos;when called with start hex&apos;, function() {
            it(&apos;returns the hexes in a rectangle shape, starting at the given start hex&apos;, function() {
                expect(rectangle({
                    width: 2,
                    height: 3,
                    start: Hex(-4, -2)
                })).to.contain.hexes([
                    { x: -4, y: -2 },
                    { x: -3, y: -2 },
                    { x: -4, y: -1 },
                    { x: -3, y: -1 },
                    { x: -4, y: 0 },
                    { x: -3, y: 0 }
                ])
            })
        })

        describe(&apos;when called with direction 0&apos;, function() {
            it(&apos;returns the hexes in a rectangle shape, in a southeastern direction&apos;, function() {
                expect(rectangle({
                    width: 2,
                    height: 2,
                    direction: 0
                })).to.contain.hexes([
                    { x: 0, y: 0 },
                    { x: 1, y: 0 },
                    { x: 0, y: 1 },
                    { x: 1, y: 1 }
                ])
            })
        })

        describe(&apos;when called with direction 1&apos;, function() {
            it(&apos;returns the hexes in a rectangle shape, in a southern direction&apos;, function() {
                expect(rectangle({
                    width: 2,
                    height: 2,
                    direction: 1
                })).to.contain.hexes([
                    { x: 0, y: 0 },
                    { x: 0, y: 1 },
                    { x: 1, y: 0 },
                    { x: 1, y: 1 }
                ])
            })
        })

        describe(&apos;when called with direction 2&apos;, function() {
            it(&apos;returns the hexes in a rectangle shape, in a southwestern direction&apos;, function() {
                expect(rectangle({
                    width: 2,
                    height: 2,
                    direction: 2
                })).to.contain.hexes([
                    { x: -1, y: -1 },
                    { x: -2, y: 0 },
                    { x: 0, y: 0 },
                    { x: -1, y: 0 }
                ])
            })
        })

        describe(&apos;when called with direction 3&apos;, function() {
            it(&apos;returns the hexes in a rectangle shape, in a northwestern direction&apos;, function() {
                expect(rectangle({
                    width: 2,
                    height: 2,
                    direction: 3
                })).to.contain.hexes([
                    { x: -1, y: -1 },
                    { x: -2, y: 0 },
                    { x: -1, y: 0 },
                    { x: 0, y: 0 }
                ])
            })
        })

        describe(&apos;when called with direction 4&apos;, function() {
            it(&apos;returns the hexes in a rectangle shape, in a northern direction&apos;, function() {
                expect(rectangle({
                    width: 2,
                    height: 2,
                    direction: 4
                })).to.contain.hexes([
                    { x: 0, y: 0 },
                    { x: 0, y: -1 },
                    { x: 1, y: -1 },
                    { x: 1, y: -2 }
                ])
            })
        })

        describe(&apos;when called with direction 5&apos;, function() {
            it(&apos;returns the hexes in a rectangle shape, in a northeastern direction&apos;, function() {
                expect(rectangle({
                    width: 2,
                    height: 2,
                    direction: 5
                })).to.contain.hexes([
                    { x: 0, y: 0 },
                    { x: 1, y: -1 },
                    { x: 0, y: -1 },
                    { x: 1, y: -2 }
                ])
            })
        })
    })

    describe(&apos;when called with an onCreate callback&apos;, function() {
        it(&apos;calls the callback for each created hex passing the hex and the grid&apos;, function() {
            const callback = sinon.spy()
            const result = rectangle({
                width: 2,
                height: 2,
                onCreate: callback
            })
            expect(callback.callCount).to.eql(4)
            expect(callback).to.always.have.been.calledWithExactly(
                sinon.match.has(&apos;__isHoneycombHex&apos;, true),
                sinon.match.same(result)
            )
        })
    })
})
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.0.4)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
